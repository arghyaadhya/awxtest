#!/bin/bash
# ---------------------------------------------------------------------
# Citrix XenServer / Hypervisor Multi-Pool SSH Collector (final)
# Preserves logic, adds DOM0_CPU, LOAD_AVG, uptime, network bond mapping
# Outputs CSV per pool (Elasticsearch-friendly)
# ---------------------------------------------------------------------

USER="root"                   # SSH username
PASS=""                   # SSH password if not using keys
SERVER_LIST="servers.txt" # File containing XenServer pool masters (one per line)
SSH_TIMEOUT=15
USE_SSH_KEY=false          # true=SSH key, false=password
TMP_DIR="/u/arghyaa/working-script/xs_report/xenpool_collect_tmp"
DATESTAMP=$(date +%Y-%m-%d_%H-%M)
MASTER_INDEX="$TMP_DIR/xenpool_index_${DATESTAMP}.csv"

mkdir -p "$TMP_DIR"
> "$MASTER_INDEX"

[[ ! -f "$SERVER_LIST" ]] && { echo "Error: $SERVER_LIST not found!"; exit 1; }

echo "=============================================================="
echo " Citrix XenServer Multi-Pool SSH Collector (final)"
echo "=============================================================="
echo "Using server list: $SERVER_LIST"
echo "Reports directory: $TMP_DIR"
echo "=============================================================="

# --- Remote Script (runs on each XenServer host) ---
read -r -d '' REMOTE_SCRIPT <<'EOF'
#!/bin/bash
# remote script start
timestamp=$(date +"%Y-%m-%d_%H-%M")
csv_file="/tmp/xenpool_summary_${timestamp}.csv"

# Pool name (from xe)
pool_name=$(xe pool-list 2>/dev/null | awk -F: '/name-label \( RW\):/ {print $2}' | xargs)
[[ -z "$pool_name" ]] && pool_name="Standalone_Host"

# Totals
total_cpu=0
total_mem_total=0
total_mem_usable=0
total_mem_used=0
total_mem_free=0
total_ctrl_mem=0
total_vms=0

# Hosts in pool (UUID list)
hosts=$(xe host-list --minimal 2>/dev/null | tr ',' ' ')
[[ -z "$hosts" ]] && { echo "No hosts found."; exit 1; }

# Header: include DOM0_CPU and LOAD_AVG and CPU_MODEL
echo "POOL NAME,HOST NAME,CPU,CPU_MODEL,DOM0_CPU,LOAD_AVG,CTRL_MEM(GB),USED(GB),FREE(GB),TOTAL(GB),RUNNING_VM,HYPERTHREADING,UPTIME_DAYS,ETH0_STATUS,ETH0_SPEED,ETH1_STATUS,ETH1_SPEED,BOND0_STATUS,BOND0_SPEED" > "$csv_file"

# helper: get pif device from pif-uuid
pif_device() {
  local pif=$1
  xe pif-param-get uuid="$pif" param-name=device 2>/dev/null || echo ""
}

# Iterate hosts
for uuid in $hosts; do
  # Host name
  host_name=$(xe host-param-get uuid="$uuid" param-name=name-label 2>/dev/null)
  host_name=${host_name:-$uuid}

  # CPU cores (total cores reported by xe)
  cpu=$(xe host-cpu-info host-uuid="$uuid" --minimal 2>/dev/null)
  [[ -z "$cpu" ]] && cpu=0

  # CPU model: try xe output else fallback to /proc/cpuinfo
  cpu_model=$(xe host-cpu-info host-uuid="$uuid" 2>/dev/null | awk -F: '/model name/ { $1=""; gsub(/^ +| +$/,"",$0); print substr($0,2); exit }')
  if [[ -z "$cpu_model" ]]; then
    cpu_model=$(grep -m1 "model name" /proc/cpuinfo 2>/dev/null | cut -d: -f2- | xargs)
  fi
  cpu_model=${cpu_model:-"Unknown"}

  # DOM0 vCPU count (number of vcpus assigned to Domain-0)
  dom0_cpu=$(xl vcpu-list | grep 'Domain-0' | wc -l)
  dom0_cpu=${dom0_cpu:-"NA"}

  # Load avg (1-min)
  load_avg=$(awk '{print $1}' /proc/loadavg 2>/dev/null)
  load_avg=${load_avg:-"NA"}

  # Memory info
  mem_total_bytes=$(xe host-param-get uuid="$uuid" param-name=memory-total 2>/dev/null)
  mem_free_bytes=$(xe host-param-get uuid="$uuid" param-name=memory-free 2>/dev/null)
  ctrl_mem_mib=$(xl list Domain-0 2>/dev/null | awk 'NR==2 {print $3}')
  [[ -z "$ctrl_mem_mib" ]] && ctrl_mem_mib=0
  ctrl_mem_bytes=$((ctrl_mem_mib * 1024 * 1024))

  # Convert to GB (integers)
  mem_total_gb=0; mem_free_gb=0; ctrl_mem_gb=0
  if [[ -n "$mem_total_bytes" && "$mem_total_bytes" =~ ^[0-9]+$ ]]; then
    mem_total_gb=$((mem_total_bytes/1024/1024/1024))
  fi
  if [[ -n "$mem_free_bytes" && "$mem_free_bytes" =~ ^[0-9]+$ ]]; then
    mem_free_gb=$((mem_free_bytes/1024/1024/1024))
  fi
  if [[ -n "$ctrl_mem_bytes" && "$ctrl_mem_bytes" =~ ^[0-9]+$ ]]; then
    ctrl_mem_gb=$((ctrl_mem_bytes/1024/1024/1024))
  fi
  mem_used_gb=$((mem_total_gb - mem_free_gb))
  usable_mem_gb=$((mem_total_gb - ctrl_mem_gb))
  [[ $mem_used_gb -lt 0 ]] && mem_used_gb=0

  # Running VM count (exclude Control domain/name containing Control)
  vm_count=$(xe vm-list resident-on="$uuid" power-state=running 2>/dev/null | grep "name-label" | grep -vi "Control" | awk -F: '{print $2}' | xargs -n1 | wc -l)
  vm_count=${vm_count:-0}

  # Hyperthreading status
  if [[ -f /sys/devices/system/cpu/smt/active ]]; then
    smt_status=$(cat /sys/devices/system/cpu/smt/active 2>/dev/null)
    [[ "$smt_status" == "1" ]] && ht_state="Enabled" || ht_state="Disabled"
  else
    ht_state="Unknown"
  fi

  # Uptime in days
  uptime_seconds=$(cut -d' ' -f1 /proc/uptime)
  uptime_days=$(awk "BEGIN {print int($uptime_seconds / 86400)}")

  # ---------- Network: determine eth0/eth1/bond0 status and speed using xe bond/pif mapping ----------
  # helper functions using host uuid ($uuid)
  get_status() {
    local iface="$1"
    # physical nic quick check
    if [[ -f /sys/class/net/$iface/carrier ]]; then
      cat /sys/class/net/$iface/carrier 2>/dev/null | grep -q 1 && { echo "UP"; return; } || { echo "DOWN"; return; }
    fi
    # operstate fallback
    if [[ -f /sys/class/net/$iface/operstate ]]; then
      op=$(cat /sys/class/net/$iface/operstate 2>/dev/null)
      [[ "$op" == "up" ]] && { echo "UP"; return; } || { echo "DOWN"; return; }
    fi

    # Check bonds that belong to this host via xe:
    if command -v xe >/dev/null 2>&1; then
      for bond_uuid in $(xe bond-list --minimal 2>/dev/null | tr ',' ' '); do
        # get master pif uuid
        master_pif=$(xe bond-param-get uuid="$bond_uuid" param-name=master 2>/dev/null)
        [[ -z "$master_pif" ]] && continue
        # bond's host
        bond_host_uuid=$(xe pif-param-get uuid="$master_pif" param-name=host-uuid 2>/dev/null)
        [[ "$bond_host_uuid" != "'"$uuid"'" && "$bond_host_uuid" != "$uuid" ]] && continue
        # bond device name
        bond_dev=$(xe pif-param-get uuid="$master_pif" param-name=device 2>/dev/null)
        [[ "$bond_dev" == "$iface" ]] || continue
        # get slaves
        slaves=$(xe bond-param-get uuid="$bond_uuid" param-name=slaves 2>/dev/null)
        up_count=0
        for s_uuid in $(echo "$slaves" | tr ',' ' '); do
          s_dev=$(xe pif-param-get uuid="$s_uuid" param-name=device 2>/dev/null)
          if [[ -n "$s_dev" && -f /sys/class/net/$s_dev/carrier ]]; then
            cat /sys/class/net/$s_dev/carrier 2>/dev/null | grep -q 1 && ((up_count++))
          fi
        done
        [[ $up_count -gt 0 ]] && { echo "UP"; return; } || { echo "DOWN"; return; }
      done
    fi

    echo "NA"
  }

  get_speed() {
    local iface="$1"
    # direct sysfs
    if [[ -f /sys/class/net/$iface/speed ]]; then
      cat /sys/class/net/$iface/speed 2>/dev/null || echo "NA"
      return
    fi
    # Use xe bond mapping to inspect slaves
    if command -v xe >/dev/null 2>&1; then
      for bond_uuid in $(xe bond-list --minimal 2>/dev/null | tr ',' ' '); do
        master_pif=$(xe bond-param-get uuid="$bond_uuid" param-name=master 2>/dev/null)
        [[ -z "$master_pif" ]] && continue
        bond_host_uuid=$(xe pif-param-get uuid="$master_pif" param-name=host-uuid 2>/dev/null)
        [[ "$bond_host_uuid" != "'"$uuid"'" && "$bond_host_uuid" != "$uuid" ]] && continue
        bond_dev=$(xe pif-param-get uuid="$master_pif" param-name=device 2>/dev/null)
        [[ "$bond_dev" == "$iface" ]] || continue
        slaves=$(xe bond-param-get uuid="$bond_uuid" param-name=slaves 2>/dev/null)
        total=0; count=0
        for s_uuid in $(echo "$slaves" | tr ',' ' '); do
          s_dev=$(xe pif-param-get uuid="$s_uuid" param-name=device 2>/dev/null)
          if [[ -n "$s_dev" && -f /sys/class/net/$s_dev/speed ]]; then
            spd=$(cat /sys/class/net/$s_dev/speed 2>/dev/null)
            if [[ "$spd" =~ ^[0-9]+$ ]]; then
              total=$((total+spd)); count=$((count+1))
            fi
          fi
        done
        if [[ $count -gt 0 ]]; then
          echo $((total/count)); return
        fi
      done
    fi
    echo "NA"
  }

  # get eth0/eth1/bond0 statuses and speeds
  eth0_status=$(get_status eth0)
  eth0_speed=$(get_speed eth0)
  eth1_status=$(get_status eth1)
  eth1_speed=$(get_speed eth1)
  bond0_status=$(get_status bond0)
  bond0_speed=$(get_speed bond0)

  # write CSV line for this host
  echo "${pool_name},${host_name},${cpu},\"${cpu_model}\",${dom0_cpu},${load_avg},${ctrl_mem_gb},${mem_used_gb},${mem_free_gb},${usable_mem_gb},${vm_count},${ht_state},${uptime_days},${eth0_status},${eth0_speed},${eth1_status},${eth1_speed},${bond0_status},${bond0_speed}" >> "$csv_file"

  # aggregate totals
  total_cpu=$((total_cpu + cpu))
  total_mem_total=$((total_mem_total + mem_total_gb))
  total_mem_usable=$((total_mem_usable + usable_mem_gb))
  total_mem_used=$((total_mem_used + mem_used_gb))
  total_mem_free=$((total_mem_free + mem_free_gb))
  total_ctrl_mem=$((total_ctrl_mem + ctrl_mem_gb))
  total_vms=$((total_vms + vm_count))
done

# Pool level calculations
usable_mem_pool=$((total_mem_usable - total_ctrl_mem))
total_16gb_vm_cap=$((usable_mem_pool / 16))

# --- Pool Summary (tabular) ---
{
  echo ""
  echo "POOL SUMMARY"
  echo "METRIC,VALUE"
  echo "Total Running VMs,${total_vms}"
  echo "Usable Memory (GB),${usable_mem_pool}"
  echo "16GB VM Capacity (Approx),${total_16gb_vm_cap}"
} >> "$csv_file"

# --- Storage Repositories (tabular) ---
{
  echo ""
  echo "STORAGE REPOSITORIES"
  echo "SR NAME,TOTAL(GB),USED(GB),FREE(GB),TYPE"
} >> "$csv_file"

total_sr_used=0
total_sr_total=0
for sr_uuid in $(xe sr-list --minimal 2>/dev/null | tr ',' ' '); do
  sr_name=$(xe sr-param-get uuid="$sr_uuid" param-name=name-label 2>/dev/null)
  sr_total=$(xe sr-param-get uuid="$sr_uuid" param-name=physical-size 2>/dev/null)
  sr_used=$(xe sr-param-get uuid="$sr_uuid" param-name=physical-utilisation 2>/dev/null)
  sr_type=$(xe sr-param-get uuid="$sr_uuid" param-name=type 2>/dev/null)
  [[ "$sr_type" == "iso" || "$sr_type" == "udev" || -z "$sr_total" || "$sr_total" -eq 0 ]] && continue

  total_gb=$((sr_total/1024/1024/1024))
  used_gb=$((sr_used/1024/1024/1024))
  free_gb=$((total_gb - used_gb))

  echo "${sr_name},${total_gb},${used_gb},${free_gb},${sr_type}" >> "$csv_file"

  total_sr_total=$((total_sr_total + total_gb))
  total_sr_used=$((total_sr_used + used_gb))
done

total_sr_free=$((total_sr_total - total_sr_used))

# --- Pool Capacity Summary (tabular) ---
{
  echo ""
  echo "POOL CAPACITY SUMMARY"
  echo "METRIC,VALUE"
  echo "CPU Cores,${total_cpu}"
  echo "Memory Total (GB),${total_mem_total}"
  echo "Memory Used (GB),${total_mem_used}"
  echo "Memory Free (GB),${total_mem_free}"
  echo "Usable Memory (GB),${usable_mem_pool}"
  echo "SR Total (GB),${total_sr_total}"
  echo "SR Used (GB),${total_sr_used}"
  echo "SR Free (GB),${total_sr_free}"
  echo "Running VMs,${total_vms}"
} >> "$csv_file"

# final output: pool path
echo "${pool_name},${csv_file}"
# remote script end
EOF

# --- Loop through all servers in SERVER_LIST ---
for server in $(grep -v '^\s*#' "$SERVER_LIST" | xargs); do
  echo "------------------------------------------------------------------"
  echo "Connecting to $server ..."

  if [[ "$USE_SSH_KEY" == true ]]; then
    result=$(ssh -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "bash -s" <<< "$REMOTE_SCRIPT" 2>/dev/null)
  else
    result=$(sshpass -p "$PASS" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "bash -s" <<< "$REMOTE_SCRIPT" 2>/dev/null)
  fi

  pool_name=$(echo "$result" | awk -F',' '{print $1}')
  remote_csv=$(echo "$result" | awk -F',' '{print $2}')

  if [[ -z "$pool_name" || -z "$remote_csv" ]]; then
    echo "Failed to collect data from $server"
    continue
  fi

  clean_pool=$(echo "$pool_name" | tr -dc 'A-Za-z0-9_-')
  local_csv="${TMP_DIR}/${clean_pool}_${DATESTAMP}.csv"

  echo "Fetching pool [$pool_name] CSV from $server ..."
  if [[ "$USE_SSH_KEY" == true ]]; then
    scp -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server:$remote_csv" "$local_csv" >/dev/null 2>&1
  else
    sshpass -p "$PASS" scp -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server:$remote_csv" "$local_csv" >/dev/null 2>&1
  fi

  if [[ -f "$local_csv" ]]; then
    echo "Pool [$pool_name] data saved to: $local_csv"
    echo "${pool_name},${server},${local_csv}" >> "$MASTER_INDEX"
    # cleanup remote temp files
    if [[ "$USE_SSH_KEY" == true ]]; then
      ssh -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "rm -f /tmp/xenpool_summary_*.csv" >/dev/null 2>&1
    else
      sshpass -p "$PASS" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "rm -f /tmp/xenpool_summary_*.csv" >/dev/null 2>&1
    fi
  else
    echo "Failed to retrieve CSV from $server"
  fi
done

echo "------------------------------------------------------------------"
echo " All Pool Reports Collected"
echo " Master Index: $MASTER_INDEX"
echo "------------------------------------------------------------------"

# Create index_filelist.txt listing xenpool_index files (matching your existing naming pattern)
# If you also want all *_${DATESTAMP}.csv files listed, you can adapt this find invocation.
find "$TMP_DIR" -type f -name "xenpool_index_*.csv" -exec basename {} \; | sort > "${TMP_DIR}/index_filelist.txt"
echo "Index file list created: ${TMP_DIR}/index_filelist.txt"
