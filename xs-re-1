<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Citrix XenServer Dashboard</title>
<style>
body {font-family: Arial, sans-serif; background-color: #f5f8fc; color: #222; margin: 40px;}
h1 {color: #005eb8;}
select, input[type=text], input[type=date] {padding:8px; margin:5px; border-radius:5px; border:1px solid #ccc;}
table {border-collapse:collapse; width:100%; margin-top:20px; background:white;}
th, td {border:1px solid #ccc; padding:8px; text-align:left;}
th {background-color:#007bff; color:white;}
tr:nth-child(even){background-color:#f2f2f2;}
.container {max-width:1100px; margin:auto; background:#fff; padding:20px; border-radius:8px; box-shadow:0 0 10px rgba(0,0,0,0.1);}
#timer {font-size:14px; color:#666; margin-top:-10px;}
.chart-container {display:flex; flex-wrap:wrap; gap:30px; margin-top:30px; justify-content:center;}
canvas {width:250px; height:250px;}
.chart-title {text-align:center; margin-top:10px; font-weight:bold;}
.section-title {margin-top:40px; font-size:18px; font-weight:bold; color:#005eb8;}
</style>
</head>
<body>
<div class="container">
  <h1>Citrix XenServer Resource Dashboard</h1>
  <p><b>Generated:</b> <span id="genTime"></span></p>
  <p id="timer">Next auto-refresh in 60:00 minutes</p>

  <label for="dateSelect"><b>Select Date:</b></label>
  <input type="date" id="dateSelect">

  <label for="siteSelect"><b>Select Site:</b></label>
  <select id="siteSelect"><option value="">-- Select Site --</option></select>

  <label for="poolSelect"><b>Select Pool:</b></label>
  <select id="poolSelect"><option value="">-- Select Pool --</option></select>

  <label for="searchBox"><b>Search:</b></label>
  <input type="text" id="searchBox" placeholder="Search site or pool...">

  <div id="reportArea"></div>
</div>

<script>
// ===== Timer / Auto-refresh =====
const REFRESH_INTERVAL = 3600000; // 1h
let countdown = 3600;
setInterval(() => {
  countdown--;
  const m = String(Math.floor(countdown / 60)).padStart(2, '0');
  const s = String(countdown % 60).padStart(2, '0');
  document.getElementById('timer').innerText = "Next auto-refresh in " + m + ":" + s + " minutes";
}, 1000);
setTimeout(() => location.reload(), REFRESH_INTERVAL);

// ===== CSV Parser =====
function parseCSV(text) {
  return text.trim().split(/\r?\n/).map(l => l.split(',').map(x => x.trim()));
}

// ===== Data Loader =====
async function loadData(dateFile = "latest") {
  const indexFile = dateFile === "latest" ? "xenpool_index_latest.csv" : `xenpool_index_${dateFile}.csv`;
  const res = await fetch(indexFile).catch(() => null);
  if (!res || !res.ok) {
    alert(`No data found for ${dateFile}. Showing latest available report.`);
    return loadData("latest");
  }
  const indexText = await res.text();
  const lines = parseCSV(indexText).filter(l => l[0] && l[0] !== 'POOL NAME');
  const data = [];

  for (const [pool_name,, csv_path] of lines) {
    try {
      const txt = await fetch(csv_path).then(r => r.text());
      const a = txt.split(/\r?\n/);
      const site = (pool_name.match(/^AA[0-9]{2}/) || ['UNKNOWN'])[0];
      const pool = (pool_name.match(/CTX_[0-9]+/) || [pool_name])[0];
      const e = { site, pool, hosts: [] };

      let section = "main";
      for (const l of a) {
        if (l.startsWith('POOL NAME') && section === "main") continue;
        if (l.startsWith('POOL SUMMARY')) { section = "summary"; continue; }
        if (section === "main" && l.includes(',')) {
          const f = l.split(',');
          if (f.length >= 8 && f[0] !== "POOL NAME")
            e.hosts.push({ host: f[1], cpu: f[2], ctrl_mem: f[3], used: f[4], free: f[5], total: f[6], vms: f[7] });
        }
        if (l.startsWith('CPU Cores')) e.cpu = +l.split(',')[1];
        if (l.startsWith('Memory Total')) e.mem_total = +l.split(',')[1];
        if (l.startsWith('Memory Used')) e.mem_used = +l.split(',')[1];
        if (l.startsWith('SR Total')) e.sr_total = +l.split(',')[1];
        if (l.startsWith('SR Used')) e.sr_used = +l.split(',')[1];
        if (l.startsWith('Total Running VMs')) e.vms = +l.split(',')[1];
        if (l.startsWith('16GB VM Capacity')) e.vm_capacity = +l.split(',')[1];
      }
      data.push(e);
    } catch (err) { console.error("Failed", csv_path, err); }
  }
  return data;
}

// ===== Dropdowns =====
function populateDropdowns(data) {
  const siteSelect = document.getElementById('siteSelect');
  siteSelect.innerHTML = '<option value="">-- Select Site --</option>';
  [...new Set(data.map(d => d.site))].sort().forEach(site => {
    const opt = document.createElement('option');
    opt.value = site; opt.textContent = site;
    siteSelect.appendChild(opt);
  });
}
function populatePools(data) {
  const site = document.getElementById('siteSelect').value;
  const poolSelect = document.getElementById('poolSelect');
  poolSelect.innerHTML = '<option value="">-- Select Pool --</option>';
  data.filter(d => d.site === site).forEach(d => {
    const opt = document.createElement('option');
    opt.value = d.pool; opt.textContent = d.pool;
    poolSelect.appendChild(opt);
  });
  document.getElementById('reportArea').innerHTML = '';
}

// ===== Pie Chart =====
function drawPie(canvas, used, total, label, color) {
  canvas.width = 250; canvas.height = 250;
  const ctx = canvas.getContext('2d');
  const usedPct = total ? Math.min((used / total) * 100, 100) : 0;
  const angle = (usedPct / 100) * 2 * Math.PI;
  const cx = canvas.width / 2, cy = canvas.height / 2, r = 100;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.closePath();
  ctx.fillStyle = '#e5e5e5'; ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, r, -Math.PI / 2, -Math.PI / 2 + angle, false); ctx.closePath();
  ctx.fillStyle = color; ctx.fill();
  ctx.fillStyle = '#000'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(label, cx, cy - 10); ctx.fillText(`${usedPct.toFixed(1)}% Used`, cx, cy + 15);
}

// ===== Show Report =====
function showReport(data, site, pool) {
  const e = data.find(x => x.site === site && x.pool === pool);
  if (!e) { document.getElementById('reportArea').innerHTML = ''; return; }

  let html = `
  <h2>Site: ${site} | Pool: ${pool}</h2>
  <table>
    <tr><th>Metric</th><th>Value</th></tr>
    <tr><td>CPU Cores</td><td>${e.cpu || 'N/A'}</td></tr>
    <tr><td>Memory Total (GB)</td><td>${e.mem_total || 'N/A'}</td></tr>
    <tr><td>Memory Used (GB)</td><td>${e.mem_used || 'N/A'}</td></tr>
    <tr><td>SR Total (GB)</td><td>${e.sr_total || 'N/A'}</td></tr>
    <tr><td>SR Used (GB)</td><td>${e.sr_used || 'N/A'}</td></tr>
    <tr><td>Total Running VMs</td><td>${e.vms || 'N/A'}</td></tr>
    <tr><td>VM Capacity (16GB)</td><td>${e.vm_capacity || 'N/A'}</td></tr>
  </table>
  <div class="chart-container">
    <div><canvas id="memChart"></canvas><div class="chart-title">Memory Usage</div></div>
    <div><canvas id="srChart"></canvas><div class="chart-title">Storage Usage</div></div>
    <div><canvas id="vmChart"></canvas><div class="chart-title">VM Utilization</div></div>
  </div>
  <div class="section-title">Pool Host Details</div>
  <table>
    <tr><th>Host Name</th><th>CPU</th><th>Ctrl Mem (GB)</th><th>Used (GB)</th><th>Free (GB)</th><th>Total (GB)</th><th>Running VMs</th></tr>`;
  e.hosts.forEach(h => {
    html += `<tr><td>${h.host}</td><td>${h.cpu}</td><td>${h.ctrl_mem}</td><td>${h.used}</td><td>${h.free}</td><td>${h.total}</td><td>${h.vms}</td></tr>`;
  });
  html += `</table>`;
  document.getElementById('reportArea').innerHTML = html;
  drawPie(document.getElementById('memChart'), e.mem_used, e.mem_total, "Memory", "#007bff");
  drawPie(document.getElementById('srChart'), e.sr_used, e.sr_total, "Storage", "#28a745");
  drawPie(document.getElementById('vmChart'), e.vms, e.vm_capacity, "VMs", "#ff9800");
}

// ===== Search =====
function liveSearch(data, text) {
  const q = text.toLowerCase();
  const match = data.find(x => x.site.toLowerCase().includes(q) || x.pool.toLowerCase().includes(q));
  if (match) {
    document.getElementById('siteSelect').value = match.site;
    populatePools(data);
    document.getElementById('poolSelect').value = match.pool;
    showReport(data, match.site, match.pool);
  }
}

// ===== Init =====
let currentData = [];
(async function init() {
  document.getElementById('genTime').innerText = new Date().toLocaleString();
  currentData = await loadData();
  populateDropdowns(currentData);
  document.getElementById('siteSelect').addEventListener('change', () => populatePools(currentData));
  document.getElementById('poolSelect').addEventListener('change', () => showReport(currentData,
    document.getElementById('siteSelect').value,
    document.getElementById('poolSelect').value));
  document.getElementById('searchBox').addEventListener('keyup', e => liveSearch(currentData, e.target.value));
  document.getElementById('dateSelect').addEventListener('change', async e => {
    const date = e.target.value;
    if (!date) return;
    currentData = await loadData(date);
    populateDropdowns(currentData);
    document.getElementById('reportArea').innerHTML = `<p style="color:#005eb8;font-weight:bold;">Data loaded for ${date}</p>`;
  });
})();
</script>
</body>
</html>
