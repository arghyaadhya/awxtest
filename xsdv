#!/bin/bash
# ---------------------------------------------------------------------
# Citrix XenServer Interactive HTML Dashboard (v5 - Search + Live Refresh)
# ---------------------------------------------------------------------
# ‚úÖ Site + Pool dropdowns
# ‚úÖ Live search bar (filter by site/pool name)
# ‚úÖ CPU, Memory, SR, and VM capacity charts
# ‚úÖ Auto-refresh every 1 hour with countdown
# ‚úÖ Auto-detects new pools dynamically
# ‚úÖ Works fully offline
# ---------------------------------------------------------------------

OUTPUT_DIR="/tmp/xenpool_collect_tmp"
INDEX_FILE=$(ls -1t ${OUTPUT_DIR}/xenpool_index_*.csv 2>/dev/null | head -n1)
HTML_FILE="${OUTPUT_DIR}/Citrix_XenServer_Dashboard.html"

[[ -z "$INDEX_FILE" ]] && { echo "‚ùå No index file found in $OUTPUT_DIR"; exit 1; }

echo "=============================================================="
echo " Citrix XenServer Dashboard v5 (Search + Auto Refresh)"
echo "=============================================================="
echo "Index file : $INDEX_FILE"
echo "Output file: $HTML_FILE"
echo "=============================================================="

cat > "$HTML_FILE" <<'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Citrix XenServer Dashboard</title>
<style>
body { font-family: Arial, sans-serif; background-color: #f5f8fc; color: #222; margin: 40px; }
h1 { color: #005eb8; }
select, input[type=text] { padding: 8px; margin: 5px; border-radius: 5px; border: 1px solid #ccc; }
table { border-collapse: collapse; width: 100%; margin-top: 20px; background: white; }
th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
th { background-color: #007bff; color: white; }
tr:nth-child(even) { background-color: #f2f2f2; }
a { color: #007bff; text-decoration: none; }
.container { max-width: 1000px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
canvas { max-width: 400px; margin: 20px; }
.chart-container { display: flex; flex-wrap: wrap; justify-content: flex-start; align-items: center; }
#timer { font-size: 14px; color: #666; margin-top: -10px; }
#searchBox { width: 300px; }
</style>
</head>
<body>
<div class="container">
  <h1>Citrix XenServer Resource Dashboard</h1>
  <p><b>Generated:</b> <span id="genTime"></span></p>
  <p id="timer">Next auto-refresh in 60:00 minutes</p>

  <label for="siteSelect"><b>Select Site:</b></label>
  <select id="siteSelect"><option value="">-- Select Site --</option></select>

  <label for="poolSelect"><b>Select Pool:</b></label>
  <select id="poolSelect"><option value="">-- Select Pool --</option></select>

  <label for="searchBox"><b>Search:</b></label>
  <input type="text" id="searchBox" placeholder="Search site or pool...">

  <div id="reportArea"></div>
</div>

<script>
const REFRESH_INTERVAL = 3600000; // 1 hour
let countdown = 3600;

setInterval(() => {
  countdown--;
  const mins = String(Math.floor(countdown / 60)).padStart(2,'0');
  const secs = String(countdown % 60).padStart(2,'0');
  document.getElementById('timer').innerText = "Next auto-refresh in " + mins + ":" + secs + " minutes";
}, 1000);
setTimeout(() => location.reload(), REFRESH_INTERVAL);

function parseCSV(text) {
  const lines = text.trim().split(/\r?\n/);
  const arr = [];
  for (let line of lines) {
    const parts = line.split(',');
    arr.push(parts.map(x => x.trim()));
  }
  return arr;
}

async function loadData() {
  const res = await fetch('xenpool_index_latest.csv?_=' + Date.now()).catch(()=>null);
  if (!res || !res.ok) return [];
  const indexText = await res.text();
  const lines = parseCSV(indexText).filter(l => l[0] && l[0] != 'POOL NAME');
  const data = [];

  for (let [pool_name, , csv_path] of lines) {
    try {
      const poolCSV = await fetch(csv_path + '?_=' + Date.now()).then(r=>r.text());
      const arr = poolCSV.split(/\r?\n/);
      const poolName = pool_name.trim();
      const site = (poolName.match(/^AA[0-9]{2}/) || ['UNKNOWN'])[0];
      const pool = (poolName.match(/CTX_[0-9]+/) || [poolName])[0];
      const summary = {};
      let inPoolSummary=false, inCapSummary=false;
      for (const l of arr) {
        if (l.match(/^POOL SUMMARY/)) {inPoolSummary=true; continue;}
        if (l.match(/^POOL CAPACITY SUMMARY/)) {inCapSummary=true; continue;}
        if (l.trim()==='') {inPoolSummary=false; inCapSummary=false;}
        const [key,val] = l.split(',');
        if (inPoolSummary && key && val) {
          if (key.includes('Running VMs')) summary.vms = +val;
          if (key.includes('16GB VM Capacity')) summary.vm_capacity = +val;
        }
        if (inCapSummary && key && val) {
          if (key.includes('CPU Cores')) summary.cpu = +val;
          if (key.includes('Memory Total')) summary.mem_total = +val;
          if (key.includes('Memory Used')) summary.mem_used = +val;
          if (key.includes('Usable Memory')) summary.mem_usable = +val;
          if (key.includes('SR Total')) summary.sr_total = +val;
          if (key.includes('SR Used')) summary.sr_used = +val;
          if (key.includes('SR Free')) summary.sr_free = +val;
        }
      }
      data.push({...summary, site, pool, csv: csv_path});
    } catch(e) {}
  }
  return data;
}

function drawPie(ctx, usedPct, title, color) {
  const usedAngle = (usedPct / 100) * 2 * Math.PI;
  ctx.clearRect(0, 0, 300, 300);
  ctx.beginPath();
  ctx.moveTo(150,150);
  ctx.arc(150,150,100,0,usedAngle,false);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(150,150);
  ctx.arc(150,150,100,usedAngle,2*Math.PI,false);
  ctx.fillStyle = '#e5e5e5';
  ctx.fill();
  ctx.font='16px Arial';
  ctx.fillStyle='#000';
  ctx.textAlign='center';
  ctx.fillText(title + " (" + usedPct + "% used)",150,180);
}

function populateDropdowns(data) {
  const siteSel=document.getElementById('siteSelect');
  siteSel.innerHTML='<option value="">-- Select Site --</option>';
  [...new Set(data.map(d=>d.site))].sort().forEach(s=>{
    const o=document.createElement('option');o.value=s;o.textContent=s;siteSel.appendChild(o);
  });
}

function populatePools(data) {
  const site=document.getElementById('siteSelect').value;
  const poolSel=document.getElementById('poolSelect');
  poolSel.innerHTML='<option value="">-- Select Pool --</option>';
  data.filter(d=>d.site===site).forEach(p=>{
    const o=document.createElement('option');o.value=p.pool;o.textContent=p.pool;poolSel.appendChild(o);
  });
  document.getElementById('reportArea').innerHTML='';
}

function showReport(data, site, pool) {
  const entry=data.find(d=>d.site===site && d.pool===pool);
  if(!entry){document.getElementById('reportArea').innerHTML='';return;}

  const mem_used_pct=((entry.mem_used/entry.mem_total)*100).toFixed(1);
  const sr_used_pct=((entry.sr_used/entry.sr_total)*100).toFixed(1);
  const vm_used_pct=((entry.vms/entry.vm_capacity)*100).toFixed(1);

  document.getElementById('reportArea').innerHTML=\`
    <h2>Site: \${site} | Pool: \${pool}</h2>
    <table>
      <tr><th>Metric</th><th>Value</th></tr>
      <tr><td>CPU Cores</td><td>\${entry.cpu}</td></tr>
      <tr><td>Memory Total (GB)</td><td>\${entry.mem_total}</td></tr>
      <tr><td>Memory Used (GB)</td><td>\${entry.mem_used}</td></tr>
      <tr><td>SR Total (GB)</td><td>\${entry.sr_total}</td></tr>
      <tr><td>SR Used (GB)</td><td>\${entry.sr_used}</td></tr>
      <tr><td>Total Running VMs</td><td>\${entry.vms}</td></tr>
      <tr><td>VM Capacity (16GB)</td><td>\${entry.vm_capacity}</td></tr>
      <tr><td>CSV Report</td><td><a href="\${entry.csv}" target="_blank">Open CSV</a></td></tr>
    </table>
    <div class='chart-container'>
      <canvas id='memChart' width='300' height='300'></canvas>
      <canvas id='srChart' width='300' height='300'></canvas>
      <canvas id='vmChart' width='300' height='300'></canvas>
    </div>\`;

  drawPie(document.getElementById('memChart').getContext('2d'), mem_used_pct, 'Memory', '#007bff');
  drawPie(document.getElementById('srChart').getContext('2d'), sr_used_pct, 'Storage', '#28a745');
  drawPie(document.getElementById('vmChart').getContext('2d'), vm_used_pct, 'VM Capacity', '#ff9800');
}

function liveSearch(data, text) {
  const query=text.toLowerCase();
  const match=data.find(d=>d.site.toLowerCase().includes(query)||d.pool.toLowerCase().includes(query));
  if(match){document.getElementById('siteSelect').value=match.site;populatePools(data);
    document.getElementById('poolSelect').value=match.pool;
    showReport(data, match.site, match.pool);}
}

(async ()=>{
  document.getElementById('genTime').innerText=new Date().toLocaleString();
  const data=await loadData();
  window.dashboardData=data;
  populateDropdowns(data);
  document.getElementById('siteSelect').addEventListener('change',()=>populatePools(data));
  document.getElementById('poolSelect').addEventListener('change',()=>showReport(data, document.getElementById('siteSelect').value, document.getElementById('poolSelect').value));
  document.getElementById('searchBox').addEventListener('keyup',e=>liveSearch(data,e.target.value));
})();
</script>
</body>
</html>
EOF

# Copy the latest index for live fetch
cp -f "$INDEX_FILE" "${OUTPUT_DIR}/xenpool_index_latest.csv"

echo "‚úÖ Dashboard v5 created: $HTML_FILE"
echo "üîç Live search, auto-refresh, and auto-detect new pools enabled."
echo "üëâ Open it in your browser."
