#!/bin/bash
# ---------------------------------------------------------------------
# Citrix XenServer / Hypervisor Multi-Pool SSH Collector (final layout)
# Final production version:
#  - Lockfile to avoid overlapping cron runs
#  - Configurable NET_SAMPLE_SEC for network sampling
#  - Adds CPU_UTIL(%), MEM_UTIL(%), NET_UTIL(%) per-host (top table)
#  - Adds CPU/MEM/NET Util (%) to the single "summary," pool row
#  - Uses existing SR logic (no PBD), NFS section unchanged
#  - Optimized VM-size counting
# ---------------------------------------------------------------------

LOCKFILE="/tmp/xenpool_collect.lock"

# Prevent overlapping runs
if [ -e "$LOCKFILE" ] && kill -0 "$(cat "$LOCKFILE")" 2>/dev/null; then
  echo "Another xenpool_collect run is still in progress. Exiting safely."
  exit 0
fi

# Create lockfile and ensure it's removed on exit
echo $$ > "$LOCKFILE"
trap 'rm -f "$LOCKFILE"' EXIT

# ---------------- Configuration ----------------
USER="root"
PASS="justD0it!"
SSHPASS_BIN="/usr/bin/sshpass"
SERVER_LIST="/u/arghyaa/working-script/xs_report/servers.txt"
SSH_TIMEOUT=15
USE_SSH_KEY=false
TMP_DIR="/SCRATCH/report/xenpool_collect_tmp"
DATESTAMP=$(date +%Y-%m-%d_%H-%M)
MASTER_INDEX="$TMP_DIR/xenpool_index_${DATESTAMP}.csv"
NET_SAMPLE_SEC=2         # configurable network sample seconds
# ------------------------------------------------

mkdir -p "$TMP_DIR"
> "$MASTER_INDEX"

[[ ! -f "$SERVER_LIST" ]] && { echo "Error: $SERVER_LIST not found!"; exit 1; }

echo "=============================================================="
echo " Citrix XenServer Multi-Pool SSH Collector (final layout)"
echo "=============================================================="
echo "Using server list: $SERVER_LIST"
echo "Reports directory: $TMP_DIR"
echo "NET_SAMPLE_SEC: $NET_SAMPLE_SEC"
echo "=============================================================="

# --- Remote Script (runs on each XenServer host) ---
read -r -d '' REMOTE_SCRIPT <<'EOF'
timestamp=$(date +"%Y-%m-%d_%H-%M")
csv_file="/tmp/xenpool_summary_${timestamp}.csv"

pool_name=$(xe pool-list 2>/dev/null | awk -F: '/name-label \( RW\):/ {print $2}' | xargs)
[[ -z "$pool_name" ]] && pool_name="Standalone_Host"

total_cpu=0
total_mem_total=0
total_mem_usable=0
total_mem_used=0
total_mem_free=0
total_ctrl_mem=0
total_vms=0

# accumulators for pool-level utilization averages
sum_cpu_util=0
sum_mem_util=0
sum_net_util=0
host_util_count=0

hosts=$(xe host-list --minimal 2>/dev/null | tr ',' ' ')
[[ -z "$hosts" ]] && { echo "No hosts found."; exit 1; }

# Header (unchanged except appended util columns before SR NAME)
echo "#POOL NAME,HOST NAME,CPU,CPU_MODEL,DOM0_CPU,LOAD_AVG,CTRL_MEM(GB),USED_MEM(GB),FREE_MEM(GB),TOTAL_MEM(GB),RUNNING_VM,HYPERTHREADING,UPTIME_DAYS,ETH0_STATUS,ETH0_SPEED,ETH0_MAC,ETH1_STATUS,ETH1_SPEED,ETH1_MAC,BOND0_STATUS,BOND0_SPEED,CPU_UTIL(%),MEM_UTIL(%),NET_UTIL(%),SR NAME,SR TOTAL(GB),SR USED(GB),SR FREE(GB),SR TYPE" > "$csv_file"

# -------------------------
# Collect SR info once (store name, type, totals) - same logic you used
# -------------------------
declare -A SR_NAME SR_TYPE SR_TOTAL SR_USED SR_FREE
for sr_uuid in $(xe sr-list --minimal 2>/dev/null | tr ',' ' '); do
  sr_name_full=$(xe sr-param-get uuid="$sr_uuid" param-name=name-label 2>/dev/null)
  sr_type_full=$(xe sr-param-get uuid="$sr_uuid" param-name=type 2>/dev/null)
  [[ "$sr_type_full" == "iso" || "$sr_type_full" == "udev" || -z "$sr_name_full" ]] && continue
  sr_total=$(xe sr-param-get uuid="$sr_uuid" param-name=physical-size 2>/dev/null)
  sr_used=$(xe sr-param-get uuid="$sr_uuid" param-name=physical-utilisation 2>/dev/null)
  [[ -z "$sr_total" || "$sr_total" -eq 0 ]] && continue
  SR_NAME["$sr_uuid"]="$sr_name_full"
  SR_TYPE["$sr_uuid"]="$sr_type_full"
  SR_TOTAL["$sr_uuid"]=$((sr_total/1024/1024/1024))
  SR_USED["$sr_uuid"]=$((sr_used/1024/1024/1024))
  SR_FREE["$sr_uuid"]=$(( SR_TOTAL["$sr_uuid"] - SR_USED["$sr_uuid"] ))
done

# Helper: select primary interface to sample: bond0 -> eth0 -> eth1
select_iface() {
  if [[ -d /sys/class/net/bond0 ]]; then
    echo "bond0"
  elif [[ -d /sys/class/net/eth0 ]]; then
    echo "eth0"
  elif [[ -d /sys/class/net/eth1 ]]; then
    echo "eth1"
  else
    echo ""
  fi
}

# For each host
for uuid in $hosts; do
  host_name=$(xe host-param-get uuid="$uuid" param-name=name-label 2>/dev/null)
  host_name=${host_name:-$uuid}
  cpu=$(xe host-cpu-info host-uuid="$uuid" --minimal 2>/dev/null)
  [[ -z "$cpu" || "$cpu" == "0" ]] && cpu=1   # avoid div0

  cpu_model=$(xe host-cpu-info host-uuid="$uuid" 2>/dev/null | awk -F: '/model name/ { $1=""; gsub(/^ +| +$/,"",$0); print substr($0,2); exit }')
  [[ -z "$cpu_model" ]] && cpu_model=$(grep -m1 "model name" /proc/cpuinfo 2>/dev/null | cut -d: -f2- | xargs)
  cpu_model=${cpu_model:-"Unknown"}

  # dom0 vcpu count (kept for compatibility)
  dom0_cpu=$(xl vcpu-list | grep 'Domain-0' | wc -l)
  dom0_cpu=${dom0_cpu:-"NA"}

  load_avg=$(awk '{print $1}' /proc/loadavg 2>/dev/null)
  load_avg=${load_avg:-"0"}

  mem_total_bytes=$(xe host-param-get uuid="$uuid" param-name=memory-total 2>/dev/null)
  mem_free_bytes=$(xe host-param-get uuid="$uuid" param-name=memory-free 2>/dev/null)
  ctrl_mem_mib=$(xl list Domain-0 2>/dev/null | awk 'NR==2 {print $3}')
  [[ -z "$ctrl_mem_mib" ]] && ctrl_mem_mib=0
  ctrl_mem_bytes=$((ctrl_mem_mib * 1024 * 1024))

  mem_total_gb=$((mem_total_bytes/1024/1024/1024))
  mem_free_gb=$((mem_free_bytes/1024/1024/1024))
  ctrl_mem_gb=$((ctrl_mem_bytes/1024/1024/1024))
  mem_used_gb=$((mem_total_gb - mem_free_gb))
  usable_mem_gb=$((mem_total_gb - ctrl_mem_gb))
  [[ $mem_used_gb -lt 0 ]] && mem_used_gb=0
  [[ $mem_total_gb -le 0 ]] && mem_total_gb=0

  vm_count=$(xe vm-list resident-on="$uuid" power-state=running 2>/dev/null | grep "name-label" | grep -vi "Control" | wc -l)
  vm_count=${vm_count:-0}

  if [[ -f /sys/devices/system/cpu/smt/active ]]; then
    smt_status=$(cat /sys/devices/system/cpu/smt/active 2>/dev/null)
    [[ "$smt_status" == "1" ]] && ht_state="Enabled" || ht_state="Disabled"
  else
    ht_state="Unknown"
  fi

  uptime_days=$(awk '{print int($1/86400)}' /proc/uptime)

  get_status() {
    local iface="$1"
    [[ -f /sys/class/net/$iface/carrier ]] && grep -q 1 /sys/class/net/$iface/carrier && echo "UP" || echo "DOWN"
  }

  get_speed_val() {
    local iface="$1"
    if [[ -f /sys/class/net/$iface/speed ]]; then
      cat /sys/class/net/$iface/speed 2>/dev/null || echo "NA"
    else
      echo "NA"
    fi
  }

  get_mac() {
    local iface="$1"
    [[ -f /sys/class/net/$iface/address ]] && cat /sys/class/net/$iface/address
  }

  eth0_status=$(get_status eth0)
  eth0_speed=$(get_speed_val eth0)
  eth0_mac=$(get_mac eth0)
  eth1_status=$(get_status eth1)
  eth1_speed=$(get_speed_val eth1)
  eth1_mac=$(get_mac eth1)
  bond0_status=$(get_status bond0)
  bond0_speed=$(get_speed_val bond0)

  # ----------------------------
  # Network sampling: pick iface and measure rx/tx bytes over NET_SAMPLE_SEC
  # ----------------------------
  iface=$(select_iface)
  net_util_percent=0
  if [[ -n "$iface" ]]; then
    rx1=0; tx1=0; rx2=0; tx2=0
    if [[ -f /sys/class/net/"$iface"/statistics/rx_bytes ]]; then
      rx1=$(cat /sys/class/net/"$iface"/statistics/rx_bytes 2>/dev/null || echo 0)
      tx1=$(cat /sys/class/net/"$iface"/statistics/tx_bytes 2>/dev/null || echo 0)
      sleep ${NET_SAMPLE_SEC}
      rx2=$(cat /sys/class/net/"$iface"/statistics/rx_bytes 2>/dev/null || echo 0)
      tx2=$(cat /sys/class/net/"$iface"/statistics/tx_bytes 2>/dev/null || echo 0)
      delta_bytes=$(( (rx2 - rx1) + (tx2 - tx1) ))
      # MB/s measured over the sample interval
      mb_per_sec=$(awk -v d="$delta_bytes" -v s="${NET_SAMPLE_SEC}" 'BEGIN{ if (s>0) printf "%.6f", (d/(s*1024*1024)); else print "0" }')
      # Interface speed in Mbps -> convert to MB/s: Mbps / 8 = MB/s
      iface_speed_mbps=$(get_speed_val "$iface")
      if [[ "$iface_speed_mbps" =~ ^[0-9]+$ ]] && [[ "$iface_speed_mbps" -gt 0 ]]; then
        iface_speed_mbps_num=$iface_speed_mbps
        iface_speed_mbps_float=$(awk -v v="$iface_speed_mbps_num" 'BEGIN{printf "%.6f", v}')
        iface_speed_mbps_to_mbps="$iface_speed_mbps_float"
        iface_speed_mb_per_sec=$(awk -v m="$iface_speed_mbps_to_mbps" 'BEGIN{printf "%.6f", (m/8)}')
        # net_util_percent = (mb_per_sec / iface_speed_mb_per_sec) * 100
        net_util_percent=$(awk -v a="$mb_per_sec" -v b="$iface_speed_mb_per_sec" 'BEGIN{ if (b>0) printf "%.1f", (a/b*100); else print "0.0" }')
        # cap at 100
        net_util_percent=$(awk -v n="$net_util_percent" 'BEGIN{ if (n>100) print "100.0"; else print n }')
      else
        # unknown interface speed -> set to 0.0
        net_util_percent="0.0"
      fi
    else
      net_util_percent="0.0"
    fi
  else
    net_util_percent="0.0"
  fi

  # ----------------------------
  # Local storage aggregation: match SR names to host name (exact substring, case-insensitive)
  # (same logic you requested)
  # ----------------------------
  sr_total_gb=0
  sr_used_gb=0
  sr_free_gb=0
  for sr_uuid in "${!SR_NAME[@]}"; do
    sr_nm="${SR_NAME[$sr_uuid]}"
    sr_type="${SR_TYPE[$sr_uuid]}"
    if [[ "$sr_type" == "lvm" || "$sr_type" == "ext" ]]; then
      # case-insensitive substring match
      if echo "$sr_nm" | tr '[:upper:]' '[:lower:]' | grep -qi "$(echo "$host_name" | tr '[:upper:]' '[:lower:]')" ; then
        sr_total_gb=$((sr_total_gb + SR_TOTAL[$sr_uuid]))
        sr_used_gb=$((sr_used_gb + SR_USED[$sr_uuid]))
        sr_free_gb=$((sr_free_gb + SR_FREE[$sr_uuid]))
      fi
    fi
  done
  sr_name="${host_name}"
  sr_type="local_storage"

  # ----------------------------
  # Optimized VM-size counting (one xe call)
  # ----------------------------
  count_16gb=0
  count_32gb=0
  TARGET_16GB=$((16 * 1024 * 1024 * 1024))
  TARGET_32GB=$((32 * 1024 * 1024 * 1024))

  vm_mem_list=$(xe vm-list resident-on="$uuid" is-control-domain=false power-state=running params=memory-static-max --minimal 2>/dev/null | tr ',' ' ')
  if [[ -n "$vm_mem_list" ]]; then
    for mem in $vm_mem_list; do
      [[ -z "$mem" ]] && continue
      if [[ "$mem" =~ ^[0-9]+$ ]]; then
        if [[ "$mem" -eq "$TARGET_16GB" ]]; then
          count_16gb=$((count_16gb + 1))
        elif [[ "$mem" -eq "$TARGET_32GB" ]]; then
          count_32gb=$((count_32gb + 1))
        fi
      fi
    done
  fi

  # ----------------------------
  # Compute per-host util percentages
  # CPU util approximation: (load_avg / cpu_cores) * 100
  # MEM util: (mem_used_gb / mem_total_gb) * 100
  # NET util computed above
  # ----------------------------
  cpu_util_percent=$(awk -v la="$load_avg" -v cores="$cpu" 'BEGIN{ if (cores>0) printf "%.1f", (la/cores*100); else print "0.0" }')
  cpu_util_percent=$(awk -v v="$cpu_util_percent" 'BEGIN{ if (v>100) print "100.0"; else printf "%.1f", v }')

  if [[ $mem_total_gb -gt 0 ]]; then
    mem_util_percent=$(awk -v u="$mem_used_gb" -v t="$mem_total_gb" 'BEGIN{ printf "%.1f", (u/t*100) }')
    mem_util_percent=$(awk -v v="$mem_util_percent" 'BEGIN{ if (v>100) print "100.0"; else printf "%.1f", v }')
  else
    mem_util_percent="0.0"
  fi

  # accumulate for pool averages
  sum_cpu_util=$(awk -v a="$sum_cpu_util" -v b="$cpu_util_percent" 'BEGIN{printf "%.6f", a + b}')
  sum_mem_util=$(awk -v a="$sum_mem_util" -v b="$mem_util_percent" 'BEGIN{printf "%.6f", a + b}')
  sum_net_util=$(awk -v a="$sum_net_util" -v b="$net_util_percent" 'BEGIN{printf "%.6f", a + b}')
  host_util_count=$((host_util_count + 1))

  # Write host row (with new util columns)
  echo "poolhost,${pool_name},${host_name},${cpu},\"${cpu_model}\",${dom0_cpu},${load_avg},${ctrl_mem_gb},${mem_used_gb},${mem_free_gb},${mem_total_gb},${vm_count},${ht_state},${uptime_days},${eth0_status},${eth0_speed},${eth0_mac},${eth1_status},${eth1_speed},${eth1_mac},${bond0_status},${bond0_speed},${cpu_util_percent},${mem_util_percent},${net_util_percent},${sr_name},${sr_total_gb},${sr_used_gb},${sr_free_gb},${sr_type}" >> "$csv_file"

  total_cpu=$((total_cpu + cpu))
  total_mem_total=$((total_mem_total + mem_total_gb))
  total_mem_usable=$((total_mem_usable + usable_mem_gb))
  total_mem_used=$((total_mem_used + mem_used_gb))
  total_mem_free=$((total_mem_free + mem_free_gb))
  total_ctrl_mem=$((total_ctrl_mem + ctrl_mem_gb))
  total_vms=$((total_vms + vm_count))
done

# compute pool averages (rounded to 1 decimal)
if [[ $host_util_count -gt 0 ]]; then
  avg_cpu_util=$(awk -v s="$sum_cpu_util" -v c="$host_util_count" 'BEGIN{printf "%.1f", s/c}')
  avg_mem_util=$(awk -v s="$sum_mem_util" -v c="$host_util_count" 'BEGIN{printf "%.1f", s/c}')
  avg_net_util=$(awk -v s="$sum_net_util" -v c="$host_util_count" 'BEGIN{printf "%.1f", s/c}')
else
  avg_cpu_util="0.0"
  avg_mem_util="0.0"
  avg_net_util="0.0"
fi

usable_mem_pool=$((total_mem_usable - total_ctrl_mem))
total_16gb_vm_cap=$((usable_mem_pool / 16))
total_32gb_vm_cap=$((usable_mem_pool / 32))

# --- Pool-level SR totals (derived from SR map). Do NOT print individual local SRs here.
total_sr_total=0
total_sr_used=0
for sr_uuid in "${!SR_TOTAL[@]}"; do
  total_sr_total=$((total_sr_total + SR_TOTAL[$sr_uuid]))
  total_sr_used=$((total_sr_used + SR_USED[$sr_uuid]))
done
total_sr_free=$((total_sr_total - total_sr_used))

{
  echo ""
  echo "POOL CAPACITY SUMMARY"
  # Extended header: append util columns
  echo "METRIC,VALUE"
  echo "CPU Cores,${total_cpu}"
  echo "Memory Total (GB),${total_mem_total}"
  echo "Memory Used (GB),${total_mem_used}"
  echo "Memory Free (GB),${total_mem_free}"
  echo "Usable Memory (GB),${usable_mem_pool}"
  echo "SR Total (GB),${total_sr_total}"
  echo "SR Used (GB),${total_sr_used}"
  echo "SR Free (GB),${total_sr_free}"
  echo "Running VMs,${total_vms}"
  echo "16GB VM Capacity (Approx),${total_16gb_vm_cap}"
  echo "32GB VM Capacity (Approx),${total_32gb_vm_cap}"
  # Append new UTILIZATION fields as separate METRIC lines for readability, but we'll also add them to the single summary row below
  # (pool single-row summary created later)
} >> "$csv_file"

# --- FINAL OUTPUT REFORMAT ---
final_csv="/tmp/xenpool_final_${timestamp}.csv"

#  Host & SR table (everything before POOL CAPACITY SUMMARY)
awk 'BEGIN{p=1} /^POOL CAPACITY SUMMARY/{p=0} p' "$csv_file" > "$final_csv"

#  NFS REPOS (dynamic) - unchanged
echo "" >> "$final_csv"
echo "#NFS REPOSITORIES" >> "$final_csv"
echo "#TYPE,SR NAME,TOTAL(GB),USED(GB),FREE(GB)" >> "$final_csv"
xe sr-list type=nfs --minimal 2>/dev/null | tr ',' ' ' | while read -r nfs_sr; do
  [[ -z "$nfs_sr" ]] && continue
  sr_name_nfs=$(xe sr-param-get uuid="$nfs_sr" param-name=name-label 2>/dev/null)
  sr_total_nfs=$(xe sr-param-get uuid="$nfs_sr" param-name=physical-size 2>/dev/null)
  sr_used_nfs=$(xe sr-param-get uuid="$nfs_sr" param-name=physical-utilisation 2>/dev/null)
  [[ -z "$sr_total_nfs" || -z "$sr_used_nfs" ]] && continue
  total_gb_nfs=$((sr_total_nfs/1024/1024/1024))
  used_gb_nfs=$((sr_used_nfs/1024/1024/1024))
  free_gb_nfs=$((total_gb_nfs - used_gb_nfs))
  echo "nfs,${sr_name_nfs},${total_gb_nfs},${used_gb_nfs},${free_gb_nfs}" >> "$final_csv"
done

#  POOL SUMMARY (single-row) - extended header and single summary row
echo "" >> "$final_csv"
echo "#POOL SUMMARY" >> "$final_csv"
# Original header fields + appended utilization columns
echo "#CPU Cores,Memory Total (GB),Memory Used (GB),Memory Free (GB),Usable Memory (GB),SR Used (GB),SR Free (GB),Running VMs,16GB VM Capacity (Approx),32GB VM Capacity (Approx),CPU Utilization (%),Memory Utilization (%),Network Utilization (%)" >> "$final_csv"
# single summary row - include avg_cpu_util, avg_mem_util, avg_net_util
echo "summary,${total_cpu},${total_mem_total},${total_mem_used},${total_mem_free},${usable_mem_pool},${total_sr_used},${total_sr_free},${total_vms},${total_16gb_vm_cap},${total_32gb_vm_cap},${avg_cpu_util},${avg_mem_util},${avg_net_util}" >> "$final_csv"

# Return pool name and final csv path to caller
echo "${pool_name},${final_csv}"
EOF

# --- Loop over pool masters ---
while read -r server; do
  [[ -z "$server" || "$server" =~ ^\s*# ]] && continue

  echo "------------------------------------------------------------------"
  echo "Connecting to $server ..."
  if [[ "$USE_SSH_KEY" == true ]]; then
    result=$(ssh -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "bash -s" <<< "$REMOTE_SCRIPT" 2>/dev/null)
  else
    result=$($SSHPASS_BIN -p "$PASS" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "bash -s" <<< "$REMOTE_SCRIPT" 2>/dev/null)
  fi

  pool_name=$(echo "$result" | awk -F',' '{print $1}')
  remote_csv=$(echo "$result" | awk -F',' '{print $2}')

  [[ -z "$pool_name" || -z "$remote_csv" ]] && { echo "Failed to collect data from $server"; continue; }

  clean_pool=$(echo "$pool_name" | tr -dc 'A-Za-z0-9_-')
  local_csv="${TMP_DIR}/${clean_pool}_${DATESTAMP}.csv"

  echo "Fetching pool [$pool_name] CSV from $server ..."
  if [[ "$USE_SSH_KEY" == true ]]; then
    scp -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server:$remote_csv" "$local_csv" >/dev/null 2>&1
  else
    $SSHPASS_BIN -p "$PASS" scp -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server:$remote_csv" "$local_csv" >/dev/null 2>&1
  fi

  if [[ -f "$local_csv" ]]; then
    echo "Pool [$pool_name] data saved to: $local_csv"
    echo "${pool_name},${server},${local_csv}" >> "$MASTER_INDEX"
  else
    echo "Failed to retrieve CSV from $server"
  fi
done < <(grep -v '^\s*#' "$SERVER_LIST" | sed '/^\s*$/d')

echo "------------------------------------------------------------------"
echo " All Pool Reports Collected"
echo " Master Index: $MASTER_INDEX"
echo "------------------------------------------------------------------"

find "$TMP_DIR" -type f -name "xenpool_index_*.csv" -exec basename {} \; | sort > "${TMP_DIR}/index_filelist.txt"
echo "Index file list created: ${TMP_DIR}/index_filelist.txt"

#cp /u/arghyaa/working-script/xs_report/xenpool_collect_tmp/*.csv /u/arghyaa/citrix-report/ 2>/dev/null || true

# lockfile cleanup (safe-guard if trap missed)
rm -f "$LOCKFILE" 2>/dev/null || true

exit 0
