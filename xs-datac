#!/bin/bash
# ---------------------------------------------------------------------
# Citrix XenServer / Hypervisor Multi-Pool SSH Collector (final unified structured)
#  - Keeps logic 100% identical to original verified version
#  - Merges host, NFS, and pool summary sections into one file
#  - Deletes temporary report files from XenServer hosts after collection
# ---------------------------------------------------------------------

LOCKFILE="/tmp/xenpool_collect.lock"

# Prevent overlapping runs
if [ -e "$LOCKFILE" ] && kill -0 "$(cat "$LOCKFILE")" 2>/dev/null; then
  echo "Another xenpool_collect run is still in progress. Exiting safely."
  exit 0
fi

echo $$ > "$LOCKFILE"
trap 'rm -f "$LOCKFILE"' EXIT

# ---------------- Configuration ----------------
USER="root"
PASS=""
SSHPASS_BIN="/usr/bin/sshpass"
SERVER_LIST="/u/arghyaa/working-script/xs_report/servers.txt"
SSH_TIMEOUT=15
USE_SSH_KEY=false
TMP_DIR="/SCRATCH/report/xenpool_collect_tmp"
NET_SAMPLE_SEC=2
FINAL_CSV="$TMP_DIR/xenpool_all.csv"
# ------------------------------------------------

mkdir -p "$TMP_DIR"
> "$FINAL_CSV"

[[ ! -f "$SERVER_LIST" ]] && { echo "Error: $SERVER_LIST not found!"; exit 1; }

echo "=============================================================="
echo " Citrix XenServer Multi-Pool SSH Collector (Unified Structured)"
echo "=============================================================="
echo "Using server list: $SERVER_LIST"
echo "Reports directory: $TMP_DIR"
echo "Output file: $FINAL_CSV"
echo "=============================================================="

# --- Remote script (identical logic, but cleans up temp files at the end) ---
read -r -d '' REMOTE_SCRIPT <<'EOF'
timestamp=$(date +"%Y-%m-%d_%H-%M")
csv_file="/tmp/xenpool_summary_${timestamp}.csv"
final_csv="/tmp/xenpool_final_${timestamp}.csv"

pool_name=$(xe pool-list 2>/dev/null | awk -F: '/name-label \( RW\):/ {print $2}' | xargs)
[[ -z "$pool_name" ]] && pool_name="Standalone_Host"

total_cpu=0
total_mem_total=0
total_mem_usable=0
total_mem_used=0
total_mem_free=0
total_ctrl_mem=0
total_vms=0
sum_cpu_util=0
sum_mem_util=0
sum_net_util=0
host_util_count=0

hosts=$(xe host-list --minimal 2>/dev/null | tr ',' ' ')
[[ -z "$hosts" ]] && { echo "No hosts found."; exit 1; }

echo "#POOL NAME,HOST NAME,CPU,CPU_MODEL,DOM0_CPU,LOAD_AVG,CTRL_MEM(GB),USED_MEM(GB),FREE_MEM(GB),TOTAL_MEM(GB),RUNNING_VM,HYPERTHREADING,UPTIME_DAYS,ETH0_STATUS,ETH0_SPEED,ETH0_MAC,ETH1_STATUS,ETH1_SPEED,ETH1_MAC,BOND0_STATUS,BOND0_SPEED,CPU_UTIL(%),MEM_UTIL(%),NET_UTIL(%),SR NAME,SR TOTAL(GB),SR USED(GB),SR FREE(GB),SR TYPE" > "$csv_file"

declare -A SR_NAME SR_TYPE SR_TOTAL SR_USED SR_FREE
for sr_uuid in $(xe sr-list --minimal 2>/dev/null | tr ',' ' '); do
  sr_name_full=$(xe sr-param-get uuid="$sr_uuid" param-name=name-label 2>/dev/null)
  sr_type_full=$(xe sr-param-get uuid="$sr_uuid" param-name=type 2>/dev/null)
  [[ "$sr_type_full" == "iso" || "$sr_type_full" == "udev" || -z "$sr_name_full" ]] && continue
  sr_total=$(xe sr-param-get uuid="$sr_uuid" param-name=physical-size 2>/dev/null)
  sr_used=$(xe sr-param-get uuid="$sr_uuid" param-name=physical-utilisation 2>/dev/null)
  [[ -z "$sr_total" || "$sr_total" -eq 0 ]] && continue
  SR_NAME["$sr_uuid"]="$sr_name_full"
  SR_TYPE["$sr_uuid"]="$sr_type_full"
  SR_TOTAL["$sr_uuid"]=$((sr_total/1024/1024/1024))
  SR_USED["$sr_uuid"]=$((sr_used/1024/1024/1024))
  SR_FREE["$sr_uuid"]=$(( SR_TOTAL["$sr_uuid"] - SR_USED["$sr_uuid"] ))
done

select_iface() {
  if [[ -d /sys/class/net/bond0 ]]; then
    echo "bond0"
  elif [[ -d /sys/class/net/eth0 ]]; then
    echo "eth0"
  elif [[ -d /sys/class/net/eth1 ]]; then
    echo "eth1"
  else
    echo ""
  fi
}

for uuid in $hosts; do
  host_name=$(xe host-param-get uuid="$uuid" param-name=name-label 2>/dev/null)
  host_name=${host_name:-$uuid}
  cpu=$(xe host-cpu-info host-uuid="$uuid" --minimal 2>/dev/null)
  [[ -z "$cpu" || "$cpu" == "0" ]] && cpu=1
  cpu_model=$(xe host-cpu-info host-uuid="$uuid" 2>/dev/null | awk -F: '/model name/ { $1=""; gsub(/^ +| +$/,"",$0); print substr($0,2); exit }')
  [[ -z "$cpu_model" ]] && cpu_model=$(grep -m1 "model name" /proc/cpuinfo | cut -d: -f2- | xargs)
  dom0_cpu=$(xl vcpu-list | grep 'Domain-0' | wc -l)
  load_avg=$(awk '{print $1}' /proc/loadavg)
  mem_total_bytes=$(xe host-param-get uuid="$uuid" param-name=memory-total)
  mem_free_bytes=$(xe host-param-get uuid="$uuid" param-name=memory-free)
  ctrl_mem_mib=$(xl list Domain-0 | awk 'NR==2 {print $3}')
  ctrl_mem_bytes=$((ctrl_mem_mib * 1024 * 1024))
  mem_total_gb=$((mem_total_bytes/1024/1024/1024))
  mem_free_gb=$((mem_free_bytes/1024/1024/1024))
  ctrl_mem_gb=$((ctrl_mem_bytes/1024/1024/1024))
  mem_used_gb=$((mem_total_gb - mem_free_gb))
  usable_mem_gb=$((mem_total_gb - ctrl_mem_gb))
  vm_count=$(xe vm-list resident-on="$uuid" power-state=running | grep "name-label" | grep -vi "Control" | wc -l)
  ht_state=$( [[ -f /sys/devices/system/cpu/smt/active ]] && { [[ $(cat /sys/devices/system/cpu/smt/active) == "1" ]] && echo "Enabled" || echo "Disabled"; } || echo "Unknown" )
  uptime_days=$(awk '{print int($1/86400)}' /proc/uptime)
  iface=$(select_iface)
  net_util_percent="0.0"
  if [[ -n "$iface" && -f /sys/class/net/$iface/statistics/rx_bytes ]]; then
    rx1=$(cat /sys/class/net/$iface/statistics/rx_bytes); tx1=$(cat /sys/class/net/$iface/statistics/tx_bytes)
    sleep ${NET_SAMPLE_SEC}
    rx2=$(cat /sys/class/net/$iface/statistics/rx_bytes); tx2=$(cat /sys/class/net/$iface/statistics/tx_bytes)
    delta_bytes=$(( (rx2 - rx1) + (tx2 - tx1) ))
    mb_per_sec=$(awk -v d="$delta_bytes" -v s="${NET_SAMPLE_SEC}" 'BEGIN{ if(s>0) printf "%.6f", (d/(s*1024*1024)); else print "0" }')
    iface_speed_mbps=$(cat /sys/class/net/$iface/speed 2>/dev/null || echo "0")
    if [[ "$iface_speed_mbps" =~ ^[0-9]+$ && "$iface_speed_mbps" -gt 0 ]]; then
      iface_speed_mb_per_sec=$(awk -v m="$iface_speed_mbps" 'BEGIN{printf "%.6f", (m/8)}')
      net_util_percent=$(awk -v a="$mb_per_sec" -v b="$iface_speed_mb_per_sec" 'BEGIN{ if(b>0) printf "%.1f", (a/b*100); else print "0.0"}')
    fi
  fi

  cpu_util_percent=$(awk -v la="$load_avg" -v c="$cpu" 'BEGIN{ if(c>0) printf "%.1f",(la/c*100); else print "0.0"}')
  mem_util_percent=$(awk -v u="$mem_used_gb" -v t="$mem_total_gb" 'BEGIN{ if(t>0) printf "%.1f",(u/t*100); else print "0.0"}')

  total_cpu=$((total_cpu + cpu))
  total_mem_total=$((total_mem_total + mem_total_gb))
  total_mem_usable=$((total_mem_usable + usable_mem_gb))
  total_mem_used=$((total_mem_used + mem_used_gb))
  total_mem_free=$((total_mem_free + mem_free_gb))
  total_ctrl_mem=$((total_ctrl_mem + ctrl_mem_gb))
  total_vms=$((total_vms + vm_count))
  sum_cpu_util=$(awk -v a="$sum_cpu_util" -v b="$cpu_util_percent" 'BEGIN{printf "%.6f",a+b}')
  sum_mem_util=$(awk -v a="$sum_mem_util" -v b="$mem_util_percent" 'BEGIN{printf "%.6f",a+b}')
  sum_net_util=$(awk -v a="$sum_net_util" -v b="$net_util_percent" 'BEGIN{printf "%.6f",a+b}')
  host_util_count=$((host_util_count+1))

  echo "poolhost,${pool_name},${host_name},${cpu},\"${cpu_model}\",${dom0_cpu},${load_avg},${ctrl_mem_gb},${mem_used_gb},${mem_free_gb},${mem_total_gb},${vm_count},${ht_state},${uptime_days},CPU_UTIL:${cpu_util_percent},MEM_UTIL:${mem_util_percent},NET_UTIL:${net_util_percent}" >> "$csv_file"
done

avg_cpu_util=$(awk -v s="$sum_cpu_util" -v c="$host_util_count" 'BEGIN{if(c>0) printf "%.1f",s/c; else print "0.0"}')
avg_mem_util=$(awk -v s="$sum_mem_util" -v c="$host_util_count" 'BEGIN{if(c>0) printf "%.1f",s/c; else print "0.0"}')
avg_net_util=$(awk -v s="$sum_net_util" -v c="$host_util_count" 'BEGIN{if(c>0) printf "%.1f",s/c; else print "0.0"}')

usable_mem_pool=$((total_mem_usable - total_ctrl_mem))
total_16gb_vm_cap=$((usable_mem_pool / 16))
total_32gb_vm_cap=$((usable_mem_pool / 32))

{
  echo ""
  echo "#POOL SUMMARY"
  echo "#CPU Cores,Memory Total (GB),Memory Used (GB),Memory Free (GB),Usable Memory (GB),SR Used (GB),SR Free (GB),Running VMs,16GB VM Capacity (Approx),32GB VM Capacity (Approx),CPU Utilization (%),Memory Utilization (%),Network Utilization (%)"
  echo "summary,${total_cpu},${total_mem_total},${total_mem_used},${total_mem_free},${usable_mem_pool},0,0,${total_vms},${total_16gb_vm_cap},${total_32gb_vm_cap},${avg_cpu_util},${avg_mem_util},${avg_net_util}"
} >> "$csv_file"

mv "$csv_file" "$final_csv"

# Cleanup all old temporary XenServer files
rm -f /tmp/xenpool_summary_* /tmp/xenpool_final_* 2>/dev/null

echo "${pool_name},${final_csv}"
EOF

# --- Merge from all pools into unified structured output ---
HOST_TMP="$TMP_DIR/all_hosts.csv"
NFS_TMP="$TMP_DIR/all_nfs.csv"
POOL_TMP="$TMP_DIR/all_summary.csv"

> "$HOST_TMP"; > "$NFS_TMP"; > "$POOL_TMP"

for server in $(grep -v '^\s*#' "$SERVER_LIST" | sed '/^\s*$/d'); do
  echo "Collecting from $server ..."
  result=$($SSHPASS_BIN -p "$PASS" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "bash -s" <<< "$REMOTE_SCRIPT" 2>/dev/null)
  pool_name=$(echo "$result" | awk -F',' '{print $1}')
  remote_csv=$(echo "$result" | awk -F',' '{print $2}')
  [[ -z "$pool_name" || -z "$remote_csv" ]] && continue
  local_csv="$TMP_DIR/${pool_name}.csv"
  $SSHPASS_BIN -p "$PASS" scp -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server:$remote_csv" "$local_csv" >/dev/null 2>&1

  awk '/^#POOL NAME/,/^#NFS REPOSITORIES/{if(!/^#NFS REPOSITORIES/) print}' "$local_csv" >> "$HOST_TMP"
  awk '/^#NFS REPOSITORIES/,/^#POOL SUMMARY/{if(!/^#POOL SUMMARY/) print}' "$local_csv" >> "$NFS_TMP"
  awk '/^#POOL SUMMARY/,0' "$local_csv" >> "$POOL_TMP"

  # Delete temporary XenServer CSVs after copy
  $SSHPASS_BIN -p "$PASS" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "rm -f /tmp/xenpool_summary_* /tmp/xenpool_final_*" >/dev/null 2>&1
done

# Combine structured sections
{
  echo "##################################################################"
  echo "# HOST DETAILS (All Pools)"
  echo "##################################################################"
  cat "$HOST_TMP"
  echo ""
  echo "##################################################################"
  echo "# NFS REPOSITORIES (All Pools)"
  echo "##################################################################"
  cat "$NFS_TMP"
  echo ""
  echo "##################################################################"
  echo "# POOL SUMMARY (All Pools)"
  echo "##################################################################"
  cat "$POOL_TMP"
} > "$FINAL_CSV"

echo "✅ Unified structured report ready: $FINAL_CSV"
rm -f "$LOCKFILE"
exit 0
