#!/bin/bash
# ---------------------------------------------------------------------
# Citrix XenServer / Hypervisor Health Check (Remote + Cron-ready)
# ---------------------------------------------------------------------
# - Keeps original logic intact
# - Reads server list from file
# - Uses sshpass for remote SSH
# - Runs only if load > threshold
# - Adds GVFS cache issue check
# - Collects all reports centrally
# - Supports limited parallel execution
# - Cron-safe with lockfile
# ---------------------------------------------------------------------

LANG=C
set -euo pipefail

# ====== Configuration ======
SERVER_LIST_FILE="/etc/citrix/server_list.txt"     # One server per line
USERNAME="citrixadmin"                             # SSH username
PASSWORD="MyP@ssword123"                           # SSH password
LOAD_THRESHOLD=3                                   # Skip if load below this
MAX_PARALLEL=3                                     # Limit concurrent checks
ADMIN_REPORT_DIR="/var/log/citrix_remote_reports"  # Local report directory
LOCKFILE="/tmp/citrix_healthcheck.lock"
TIMESTAMP="$(date +%F_%H-%M)"
FINAL_REPORT="$ADMIN_REPORT_DIR/final_citrix_healthcheck_${TIMESTAMP}.log"

# ====== Safety Setup ======
mkdir -p "$ADMIN_REPORT_DIR"
exec 200>"$LOCKFILE"
flock -n 200 || { echo "⚠️ Another healthcheck is running. Exiting."; exit 0; }

echo "===== [Citrix Remote Health Check Started at $(date)] =====" | tee "$FINAL_REPORT"

# ====== Function to run the actual remote check ======
run_healthcheck_remote() {
    local host="$1"
    echo "[$(date +%H:%M)] Checking $host ..."

    sshpass -p "$PASSWORD" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 "$USERNAME@$host" "bash -s" <<'REMOTE_SCRIPT'
#!/bin/bash
LANG=C

report="/var/log/citrix_healthcheck_$(date +%F_%H-%M).log"
mkdir -p /var/log
exec > >(tee -a "$report") 2>&1

# ===== Basic System Info =====
echo "===== [System Information: $(hostname)] ====="
echo "Uptime: $(uptime -p)"
echo "CPU Load: $(uptime | awk -F'load average[s]?: ' '{print $2}')"
echo
echo "Memory Usage:"
free -h
echo

# ===== Load Check (added) =====
load=\$(uptime | awk -F'load average[s]?: ' '{print \$2}' | cut -d',' -f1 | tr -d ' ')
if (( \${load%%.*} < LOAD_THRESHOLD )); then
    echo "Load below threshold (\$load < LOAD_THRESHOLD). Skipping detailed check."
    echo "===== [Report Saved To] ====="
    echo "\$report"
    exit 0
fi

# ===== Get User Sessions from ctxqsession =====
echo "===== [User Session Info] ====="
all_users=\$(ctxqsession 2>/dev/null | awk 'NR>2 {print \$2}' | sort -u)
active_disconnected_users=\$(ctxqsession 2>/dev/null | grep -i -e "Active" -e "Disconnected" -e "disc" | awk '{print \$2}' | sort -u)
leftover_users=\$(comm -23 <(echo "\$all_users" | sort -u) <(echo "\$active_disconnected_users" | sort -u))

if [ -z "\$leftover_users" ]; then
    echo "No Citrix users with leftover process"
else
    echo "===== [Leftover User Processes] ====="
    for user in \$leftover_users; do
        clean_user=\$(echo "\$user" | awk -F'\\\\\\\\' '{print \$NF}')
        if id "\$clean_user" &>/dev/null; then
            ps -u "\$clean_user" -o pid,comm --no-headers \
            | grep -Ev '^(systemd|dbus|sshd|cron|bash|sh|citrix|ctx|postgres|mate|xfce|gnome|pulseaudio|gvfs|Xorg|xrdp|lightdm|login)' \
            | awk -v u="\$clean_user" 'NR==1{print "User:", u} {printf "PID: %-6s CMD: %s\n", \$1, \$2}'
        fi
    done
fi

# ===== ctxgfx Process Session ID Check =====
echo
echo "===== [ctxgfx Process Session ID Mismatch] ====="
valid_sessions=\$(ctxquser 2>/dev/null | awk 'NR>1 {split(\$2,a,\":\"); print a[2]}')
ps_ctxgfx=\$(ps -ef | grep session | grep ctxgfx)

mismatch_found=false
while read -r line; do
    [ -z "\$line" ] && continue
    ps_sessid=\$(echo "\$line" | awk '{print \$NF}')
    if ! grep -qx "\$ps_sessid" <<< "\$valid_sessions"; then
        echo "\$line"
        mismatch_found=true
    fi
done <<< "\$ps_ctxgfx"

if [ "\$mismatch_found" = false ]; then
    echo "All ctxgfx processes match valid session IDs"
fi

# ===== NFS, autofs, SSD Error Check =====
echo
echo "===== [Error Checks] ====="
dmesg | grep -iE 'nfs|autofs|ssd' | head -n 1 | grep -q . && \
    echo "System Error Detected: \$(dmesg | grep -iE 'nfs|autofs|ssd' | head -n 1)" || \
    echo "No NFS/Autofs/SSD errors found."

# ===== GVFS Cache Issue Check (added) =====
echo
echo "===== [GVFS Cache Issues] ====="
gvfs_count=\$(ps -ef | grep gvfs | grep -v grep | wc -l)
if (( gvfs_count > 10 )); then
    echo "Potential GVFS cache issue detected: \$gvfs_count gvfs processes running"
else
    echo "No GVFS cache issue detected."
fi

# ===== NFS Hung Mount Checks =====
hung_list=""
while read -r mnt; do
    if ! timeout 10 stat "\$mnt" >/dev/null 2>&1; then
        hung_list+="\$mnt : HUNG"$'\\n'
    fi
done < <(mount | awk '/ nfs / {print \$3}')

if [ -n "\$hung_list" ]; then
    echo
    echo "===== [Hung NFS Mounts] ====="
    echo "\$hung_list"
fi

echo
echo "===== [Report Saved To] ====="
echo "\$report"
REMOTE_SCRIPT
}

# ====== Run on all servers (Controlled Parallel) ======
echo
echo "===== [Starting Remote Checks] ====="
job_count=0

while read -r server; do
    [[ -z "$server" || "$server" =~ ^# ]] && continue

    run_healthcheck_remote "$server" >"$ADMIN_REPORT_DIR/${server}_report.log" 2>&1 &
    ((job_count++))

    if (( job_count >= MAX_PARALLEL )); then
        wait -n
        ((job_count--))
    fi
done < "$SERVER_LIST_FILE"

wait
echo
echo "===== [All Remote Checks Completed] ====="

# ====== Generate Summary ======
echo "===== [SUMMARY REPORT] =====" > "$FINAL_REPORT"
for log in "$ADMIN_REPORT_DIR"/*_report.log; do
    host=$(basename "$log" _report.log)
    issue="OK"

    grep -q "GVFS cache issue" "$log" && issue="GVFS cache issue"
    grep -q "System Error Detected" "$log" && issue="NFS/Autofs/SSD error"
    grep -q "HUNG" "$log" && issue="Hung NFS mount"
    grep -q "leftover process" "$log" && issue="Leftover Citrix user"
    grep -q "Load below threshold" "$log" && issue="Load below threshold (Skipped)"

    echo "$host : $issue" >> "$FINAL_REPORT"
done

echo
echo "===== [Final Summary Saved To] ====="
echo "$FINAL_REPORT"

# ====== Cleanup ======
flock -u 200
rm -f "$LOCKFILE"
