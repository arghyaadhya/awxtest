#!/bin/bash
# ---------------------------------------------------------------------
# Citrix XenServer / Hypervisor Multi-Pool SSH Collector (Final V9)
# ---------------------------------------------------------------------
# Based on Final V8 (stable)
# Additions:
#   - Nagios-style CPU & Memory utilization sampling
#   - Correct SR Used/Free, 16GB/32GB VM capacity, usable memory
#   - All Final V8 network, cleanup, and layout logic intact
# ---------------------------------------------------------------------

LOCKFILE="/tmp/xenpool_collect.lock"
if [ -e "$LOCKFILE" ] && kill -0 "$(cat "$LOCKFILE")" 2>/dev/null; then
  echo "Another xenpool_collect run is still in progress. Exiting safely."
  exit 0
fi
echo $$ > "$LOCKFILE"
trap 'rm -f "$LOCKFILE"' EXIT

# ---------------- Configuration ----------------
USER="root"
PASS=""
SSHPASS_BIN="/usr/bin/sshpass"
SERVER_LIST="/u/arghyaa/working-script/xs_report/servers.txt"
SSH_TIMEOUT=15
USE_SSH_KEY=false
TMP_DIR="/SCRATCH/report/xenpool_collect_tmp"
DATESTAMP=$(date +%Y-%m-%d_%H-%M)
MASTER_INDEX="$TMP_DIR/xenpool_index_${DATESTAMP}.csv"
NET_SAMPLE_SEC=2
# ------------------------------------------------

mkdir -p "$TMP_DIR"
> "$MASTER_INDEX"
[[ ! -f "$SERVER_LIST" ]] && { echo "Error: $SERVER_LIST not found!"; exit 1; }

echo "=============================================================="
echo " Citrix XenServer Multi-Pool SSH Collector (Final V9)"
echo "=============================================================="

# --- Remote Script ---
read -r -d '' REMOTE_SCRIPT <<'EOF'
timestamp=$(date +"%Y-%m-%d_%H-%M")
csv_file="/tmp/xenpool_summary_${timestamp}.csv"

pool_name=$(xe pool-list 2>/dev/null | awk -F: '/name-label \( RW\):/ {print $2}' | xargs)
[[ -z "$pool_name" ]] && pool_name="Standalone_Host"
site_name=$(echo "$pool_name" | awk -F'_' '{print $1}')

hosts=$(xe host-list enabled=true --minimal 2>/dev/null | tr ',' ' ')
[[ -z "$hosts" ]] && { echo "No hosts found."; exit 1; }

echo "#KEYWORD,SITE NAME,POOL NAME,HOST NAME,CPU,CPU_MODEL,DOM0_CPU,LOAD_AVG,CTRL_MEM(GB),USED_MEM(GB),FREE_MEM(GB),TOTAL_MEM(GB),RUNNING_VM,HYPERTHREADING,UPTIME_DAYS,ETH0_STATUS,ETH0_SPEED,ETH0_MAC,ETH1_STATUS,ETH1_SPEED,ETH1_MAC,BOND0_STATUS,BOND0_SPEED,CPU_UTIL(%),MEM_UTIL(%),NET_UTIL(%),SR NAME,SR TOTAL(GB),SR USED(GB),SR FREE(GB),SR TYPE" > "$csv_file"

total_cpu=0; total_mem_total=0; total_mem_used=0; total_mem_free=0; total_ctrl_mem=0; total_vms=0
sum_cpu_util=0; sum_mem_util=0; host_util_count=0; pool_net_sum=0; pool_speed_sum=0

for uuid in $hosts; do
  host_name=$(xe host-param-get uuid="$uuid" param-name=name-label)
  host_ip=$(xe host-param-get uuid="$uuid" param-name=address)
  [[ -z "$host_ip" ]] && continue

  # --- Nagios-style CPU & MEM sampling + NET sampling (run on each host via SSH) ---
  remote_data=$($SSHPASS_BIN -p "$PASS" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@"$host_ip" "bash -s" <<'INNER'
NET_SAMPLE_SEC=2
# CPU utilization (delta sampling)
read cpu user nice system idle iowait irq softirq steal guest < /proc/stat
cpu_total1=$((user+nice+system+idle+iowait+irq+softirq+steal))
cpu_idle1=$idle
sleep $NET_SAMPLE_SEC
read cpu user nice system idle iowait irq softirq steal guest < /proc/stat
cpu_total2=$((user+nice+system+idle+iowait+irq+softirq+steal))
cpu_idle2=$idle
cpu_util=$(awk -v t1=$cpu_total1 -v t2=$cpu_total2 -v i1=$cpu_idle1 -v i2=$cpu_idle2 'BEGIN{dt=(t2-t1); di=(i2-i1); if(dt>0) printf "%.1f",(100*(1-di/dt)); else print 0}')

# Memory utilization (accounting buffers/cache)
mem_total=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
mem_free=$(awk '/MemFree/ {print $2}' /proc/meminfo)
buffers=$(awk '/Buffers/ {print $2}' /proc/meminfo)
cached=$(awk '/^Cached/ {print $2}' /proc/meminfo)
mem_used=$((mem_total - mem_free - buffers - cached))
mem_util=$(awk -v u=$mem_used -v t=$mem_total 'BEGIN{if(t>0) printf "%.1f",(u/t*100); else print 0.0}')

# Network utilization sampling
iface=$(if [[ -d /sys/class/net/bond0 ]]; then echo "bond0"; elif [[ -d /sys/class/net/eth0 ]]; then echo "eth0"; elif [[ -d /sys/class/net/eth1 ]]; then echo "eth1"; else echo ""; fi)
if [[ -n "$iface" && -f /sys/class/net/$iface/statistics/rx_bytes ]]; then
  rx1=$(cat /sys/class/net/$iface/statistics/rx_bytes)
  tx1=$(cat /sys/class/net/$iface/statistics/tx_bytes)
  sleep $NET_SAMPLE_SEC
  rx2=$(cat /sys/class/net/$iface/statistics/rx_bytes)
  tx2=$(cat /sys/class/net/$iface/statistics/tx_bytes)
  delta_bytes=$(( (rx2 - rx1) + (tx2 - tx1) ))
  iface_speed_mbps=$(cat /sys/class/net/$iface/speed 2>/dev/null || echo 0)
  iface_speed_mb_per_sec=$(awk -v m=$iface_speed_mbps 'BEGIN{printf "%.6f",(m/8)}')
  mb_per_sec=$(awk -v d=$delta_bytes -v s=$NET_SAMPLE_SEC 'BEGIN{printf "%.6f",(d/(s*1024*1024))}')
  net_util=$(awk -v a=$mb_per_sec -v b=$iface_speed_mb_per_sec 'BEGIN{if(b>0) printf "%.1f",(a/b*100); else print 0}')
else
  iface_speed_mbps=0; net_util=0
fi
echo "$cpu_util $mem_util $iface_speed_mbps $net_util"
INNER
)

  # Parse remote data
  cpu_util_percent=$(echo "$remote_data" | awk '{print $1}')
  mem_util_percent=$(echo "$remote_data" | awk '{print $2}')
  iface_speed=$(echo "$remote_data" | awk '{print $3}')
  net_util_percent=$(echo "$remote_data" | awk '{print $4}')

  # Normalize fallbacks
  [[ "$cpu_util_percent" =~ ^[0-9]+(\.[0-9]+)?$ ]] || cpu_util_percent=0
  [[ "$mem_util_percent" =~ ^[0-9]+(\.[0-9]+)?$ ]] || mem_util_percent=0
  [[ "$iface_speed" =~ ^[0-9]+$ ]] || iface_speed=0
  [[ "$net_util_percent" =~ ^[0-9]+(\.[0-9]+)?$ ]] || net_util_percent=0

  pool_net_sum=$(awk -v a="$pool_net_sum" -v b="$net_util_percent" -v s="$iface_speed" 'BEGIN{printf "%.6f",a+(b*s)}')
  pool_speed_sum=$(awk -v a="$pool_speed_sum" -v s="$iface_speed" 'BEGIN{printf "%.6f",a+s}')

  # Host static info
  cpu=$(xe host-cpu-info host-uuid="$uuid" --minimal)
  [[ -z "$cpu" || "$cpu" == "0" ]] && cpu=1
  cpu_model=$(xe host-cpu-info host-uuid="$uuid" | awk -F: '/model name/ {print $2; exit}' | xargs)
  [[ -z "$cpu_model" ]] && cpu_model="not found"
  dom0_cpu=$(xl vcpu-list | grep 'Domain-0' | wc -l)
  ctrl_mem_mib=$(xl list Domain-0 | awk 'NR==2 {print $3}')
  mem_total_bytes=$(xe host-param-get uuid="$uuid" param-name=memory-total)
  mem_free_bytes=$(xe host-param-get uuid="$uuid" param-name=memory-free)
  mem_total_gb=$((mem_total_bytes/1024/1024/1024))
  mem_free_gb=$((mem_free_bytes/1024/1024/1024))
  mem_used_gb=$((mem_total_gb - mem_free_gb))
  vm_count=$(xe vm-list resident-on="$uuid" power-state=running | grep -c "name-label")
  ht_state=$( [[ -f /sys/devices/system/cpu/smt/active ]] && grep -q 1 /sys/devices/system/cpu/smt/active && echo "Enabled" || echo "Disabled" )
  uptime_days=$(awk '{print int($1/86400)}' /proc/uptime)

  # Aggregate totals
  total_cpu=$((total_cpu + cpu))
  total_mem_total=$((total_mem_total + mem_total_gb))
  total_mem_used=$((total_mem_used + mem_used_gb))
  total_mem_free=$((total_mem_free + mem_free_gb))
  # ctrl_mem_mib is in MiB per host; convert to GB (approx) when summing
  total_ctrl_mem=$((total_ctrl_mem + (ctrl_mem_mib/1024)))
  total_vms=$((total_vms + vm_count))

  sum_cpu_util=$(awk -v a="$sum_cpu_util" -v b="$cpu_util_percent" 'BEGIN{printf "%.6f",a+b}')
  sum_mem_util=$(awk -v a="$sum_mem_util" -v b="$mem_util_percent" 'BEGIN{printf "%.6f",a+b}')
  host_util_count=$((host_util_count + 1))

  # Interface details (best-effort, fallback values)
  get_status(){ [[ -f /sys/class/net/$1/carrier ]] && grep -q 1 /sys/class/net/$1/carrier && echo "UP" || echo "DOWN"; }
  get_speed(){ [[ -f /sys/class/net/$1/speed ]] && cat /sys/class/net/$1/speed 2>/dev/null || echo 0; }
  get_mac(){ [[ -f /sys/class/net/$1/address ]] && cat /sys/class/net/$1/address || echo "not found"; }

  eth0_status=$(get_status eth0); eth0_speed=$(get_speed eth0); eth0_mac=$(get_mac eth0)
  eth1_status=$(get_status eth1); eth1_speed=$(get_speed eth1); eth1_mac=$(get_mac eth1)
  bond0_status=$(get_status bond0); bond0_speed=$(get_speed bond0)

  [[ -z "$eth0_status" ]] && eth0_status="not found"
  [[ -z "$eth1_status" ]] && eth1_status="not found"
  [[ -z "$bond0_status" ]] && bond0_status="not found"
  [[ "$eth0_speed" =~ ^[0-9]+$ ]] || eth0_speed=0
  [[ "$eth1_speed" =~ ^[0-9]+$ ]] || eth1_speed=0
  [[ "$bond0_speed" =~ ^[0-9]+$ ]] || bond0_speed=0

  # Print per-host line (NET_UTIL printed; if not found it's 0)
  echo "poolhost,${site_name},${pool_name},${host_name},${cpu},\"${cpu_model}\",${dom0_cpu},0,${ctrl_mem_mib},${mem_used_gb},${mem_free_gb},${mem_total_gb},${vm_count},${ht_state},${uptime_days},${eth0_status},${eth0_speed},${eth0_mac},${eth1_status},${eth1_speed},${eth1_mac},${bond0_status},${bond0_speed},${cpu_util_percent},${mem_util_percent},${net_util_percent},${host_name},0,0,0,local_storage" >> "$csv_file"

done

# --- Pool-level calculations ---
usable_mem_pool=$((total_mem_total - total_ctrl_mem))
total_16gb_vm_cap=$((usable_mem_pool / 16))
total_32gb_vm_cap=$((usable_mem_pool / 32))

sr_used_total=0; sr_free_total=0
for sr_uuid in $(xe sr-list --minimal 2>/dev/null | tr ',' ' '); do
  sr_type=$(xe sr-param-get uuid="$sr_uuid" param-name=type)
  [[ "$sr_type" == "nfs" || "$sr_type" == "iso" || "$sr_type" == "udev" ]] && continue
  sr_size=$(xe sr-param-get uuid="$sr_uuid" param-name=physical-size)
  sr_used=$(xe sr-param-get uuid="$sr_uuid" param-name=physical-utilisation)
  [[ -z "$sr_size" || -z "$sr_used" ]] && continue
  sr_used_total=$((sr_used_total + sr_used))
  sr_free_total=$((sr_free_total + sr_size - sr_used))
done
sr_used_total_gb=$((sr_used_total/1024/1024/1024))
sr_free_total_gb=$((sr_free_total/1024/1024/1024))

avg_cpu_util=$(awk -v s="$sum_cpu_util" -v c="$host_util_count" 'BEGIN{if(c>0) printf "%.1f",s/c; else print 0}')
avg_mem_util=$(awk -v s="$sum_mem_util" -v c="$host_util_count" 'BEGIN{if(c>0) printf "%.1f",s/c; else print 0}')
pool_net_util=$(awk -v a="$pool_net_sum" -v b="$pool_speed_sum" 'BEGIN{if(b>0) printf "%.1f",a/b; else print 0}')
[[ "$pool_net_util" =~ ^[0-9]+(\.[0-9]+)?$ ]] || pool_net_util=0

echo "" >> "$csv_file"
echo "#POOL SUMMARY" >> "$csv_file"
echo "summary,${site_name},${pool_name},${total_cpu},${total_mem_total},${total_mem_used},${total_mem_free},${usable_mem_pool},${sr_used_total_gb},${sr_free_total_gb},${total_vms},${total_16gb_vm_cap},${total_32gb_vm_cap},${avg_cpu_util},${avg_mem_util},${pool_net_util}" >> "$csv_file"

echo "${pool_name},${csv_file}"
EOF

# ------------------------------------------------------------------
# Collect data from all pool masters and copy CSVs locally
# ------------------------------------------------------------------
while read -r server; do
  [[ -z "$server" || "$server" =~ ^\s*# ]] && continue
  echo "Collecting data from $server ..."
  if [[ "$USE_SSH_KEY" == true ]]; then
    result=$(ssh -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "bash -s" <<< "$REMOTE_SCRIPT" 2>/dev/null)
  else
    result=$($SSHPASS_BIN -p "$PASS" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "bash -s" <<< "$REMOTE_SCRIPT" 2>/dev/null)
  fi
  pool_name=$(echo "$result" | awk -F',' '{print $1}')
  remote_csv=$(echo "$result" | awk -F',' '{print $2}')
  [[ -z "$pool_name" || -z "$remote_csv" ]] && continue
  clean_pool=$(echo "$pool_name" | tr -dc 'A-Za-z0-9_-')
  local_csv="${TMP_DIR}/${clean_pool}_${DATESTAMP}.csv"
  $SSHPASS_BIN -p "$PASS" scp -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server:$remote_csv" "$local_csv" >/dev/null 2>&1
  [[ -f "$local_csv" ]] && echo "${pool_name},${server},${local_csv}" >> "$MASTER_INDEX"
done < <(grep -v '^\s*#' "$SERVER_LIST" | sed '/^\s*$/d')

# ------------------------------------------------------------------
# Merge all collected per-pool CSVs into one consolidated final file
# ------------------------------------------------------------------
MERGED_CSV="${TMP_DIR}/xenpool_final_merged.csv"
> "$MERGED_CSV"
TMP_HOSTS="${TMP_DIR}/tmp_hosts_merge.csv"
TMP_NFS="${TMP_DIR}/tmp_nfs_merge.csv"
TMP_SUMMARY="${TMP_DIR}/tmp_summary_merge.csv"
> "$TMP_HOSTS"; > "$TMP_NFS"; > "$TMP_SUMMARY"

while IFS=, read -r pool_name server csv_file; do
  [[ -z "$csv_file" || ! -f "$csv_file" ]] && continue
  awk -F, '/^poolhost,/ {print}' "$csv_file" >> "$TMP_HOSTS"
  awk -F, '/^nfs,/ {print}' "$csv_file" >> "$TMP_NFS"
  awk -F, '/^summary,/ {print}' "$csv_file" >> "$TMP_SUMMARY"
done < "$MASTER_INDEX"

sort -t, -k3,3 "$TMP_HOSTS" -o "$TMP_HOSTS"
sort -t, -k3,3 "$TMP_NFS" -o "$TMP_NFS"
sort -t, -k3,3 "$TMP_SUMMARY" -o "$TMP_SUMMARY"

{
  echo "#HOST DETAILS (All Pools)"
  echo "#KEYWORD,SITE NAME,POOL NAME,HOST NAME,CPU,CPU_MODEL,DOM0_CPU,LOAD_AVG,CTRL_MEM(GB),USED_MEM(GB),FREE_MEM(GB),TOTAL_MEM(GB),RUNNING_VM,HYPERTHREADING,UPTIME_DAYS,ETH0_STATUS,ETH0_SPEED,ETH0_MAC,ETH1_STATUS,ETH1_SPEED,ETH1_MAC,BOND0_STATUS,BOND0_SPEED,CPU_UTIL(%),MEM_UTIL(%),NET_UTIL(%),SR NAME,SR TOTAL(GB),SR USED(GB),SR FREE(GB),SR TYPE"
  cat "$TMP_HOSTS"
  echo ""
  echo "#NFS REPOSITORIES (All Pools)"
  echo "#KEYWORD,SITE NAME,POOL NAME,SR NAME,TOTAL(GB),USED(GB),FREE(GB)"
  cat "$TMP_NFS"
  echo ""
  echo "#POOL SUMMARY (All Pools)"
  echo "#KEYWORD,SITE NAME,POOL NAME,CPU Cores,Memory Total (GB),Memory Used (GB),Memory Free (GB),Usable Memory (GB),SR Used (GB),SR Free (GB),Running VMs,16GB VM Capacity (Approx),32GB VM Capacity (Approx),CPU Utilization (%),Memory Utilization (%),Network Utilization (%)"
  cat "$TMP_SUMMARY"
} > "$MERGED_CSV"

echo "Merged CSV successfully written to: $MERGED_CSV"

# ------------------------------------------------------------------
# Remote and local cleanup section (Final V7/V8 logic preserved)
# ------------------------------------------------------------------
echo ""
echo "Starting cleanup of temporary files..."
mapfile -t SERVER_ARRAY < <(grep -v '^\s*#' "$SERVER_LIST" | sed '/^\s*$/d')

for server in "${SERVER_ARRAY[@]}"; do
  [[ -z "$server" ]] && continue
  echo "Cleaning remote temporary files on $server ..."
  if [[ "$USE_SSH_KEY" == true ]]; then
    ssh -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "rm -f /tmp/xenpool_summary_*.csv >/dev/null 2>&1"
  else
    $SSHPASS_BIN -p "$PASS" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" \
      "rm -f /tmp/xenpool_summary_*.csv >/dev/null 2>&1"
  fi
done

echo "Cleaning local temp directory: $TMP_DIR ..."
find "$TMP_DIR" -type f ! -name "xenpool_final_merged.csv" -exec rm -f {} +

echo "Cleanup completed. Only merged CSV retained: $MERGED_CSV"

rm -f "$LOCKFILE" 2>/dev/null || true
exit 0
