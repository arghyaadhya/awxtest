#!/bin/bash
# ---------------------------------------------------------------------
# Citrix XenServer / Hypervisor Multi-Pool SSH Collector (Final V30)
# ---------------------------------------------------------------------
#   - Layout same as V28 (no new columns)
#   - MAC detection fixed (eth0, eth1, bond0)
#   - SSH-based network utilization (bond0, 2×10G)
#   - DEBUG=true shows per-host RX/TX/Util live on console
# ---------------------------------------------------------------------

LOCKFILE="/tmp/xenpool_collect.lock"
if [ -e "$LOCKFILE" ] && kill -0 "$(cat "$LOCKFILE")" 2>/dev/null; then
  echo "Another xenpool_collect run is still in progress. Exiting safely."
  exit 0
fi
echo $$ > "$LOCKFILE"
trap 'rm -f "$LOCKFILE"' EXIT

# ---------------- Configuration ----------------
USER="root"
PASS="justD0it!"
SSHPASS_BIN="/usr/bin/sshpass"
SERVER_LIST="/u/arghyaa/working-script/xs_report/servers.txt"
SSH_TIMEOUT=15
TMP_DIR="/SCRATCH/report/xenpool_collect_tmp"
DATESTAMP=$(date +%Y-%m-%d_%H-%M)
MASTER_INDEX="$TMP_DIR/xenpool_index_${DATESTAMP}.csv"
NET_SAMPLE_SEC=2
IFACE="bond0"
IFACE_SPEED_Mbps=20000
DEBUG=true
# ------------------------------------------------

mkdir -p "$TMP_DIR"
> "$MASTER_INDEX"
[[ ! -f "$SERVER_LIST" ]] && { echo "Error: $SERVER_LIST not found!"; exit 1; }

echo "=============================================================="
echo " Citrix XenServer Multi-Pool SSH Collector (Final V30)"
echo "=============================================================="

# ---------------------------------------------------------------------
# Remote Script (runs on each XenServer host)
# ---------------------------------------------------------------------
read -r -d '' REMOTE_SCRIPT <<'EOSCRIPT'
timestamp=$(date +"%Y-%m-%d_%H-%M")
csv_file="/tmp/xenpool_summary_${timestamp}.csv"
DEBUG="${DEBUG}"

pool_name=$(xe pool-list 2>/dev/null | awk -F: '/name-label \( RW\):/ {print $2}' | xargs)
[[ -z "$pool_name" ]] && pool_name="Standalone_Host"
site_name=$(echo "$pool_name" | awk -F'_' '{print $1}')

total_cpu=0; total_mem_total=0; total_mem_used=0; total_mem_free=0
total_ctrl_mem=0; total_vms=0
sum_cpu_util=0; sum_mem_util=0; sum_net_util=0; host_util_count=0

hosts=$(xe host-list enabled=true --minimal 2>/dev/null | tr ',' ' ')
[[ -z "$hosts" ]] && { echo "No hosts found."; exit 1; }

echo "#KEYWORD,SITE NAME,POOL NAME,HOST NAME,CPU,CPU_MODEL,DOM0_CPU,LOAD_AVG,CTRL_MEM(GB),USED_MEM(GB),FREE_MEM(GB),TOTAL_MEM(GB),RUNNING_VM,HYPERTHREADING,UPTIME_DAYS,ETH0_STATUS,ETH0_SPEED,ETH0_MAC,ETH1_STATUS,ETH1_SPEED,ETH1_MAC,BOND0_STATUS,BOND0_SPEED,CPU_UTIL(%),MEM_UTIL(%),NET_UTIL(%),SR NAME,SR TOTAL(GB),SR USED(GB),SR FREE(GB),SR TYPE" > "$csv_file"

for uuid in $hosts; do
  host_name=$(xe host-param-get uuid="$uuid" param-name=name-label)
  host_ip=$(xe host-param-get uuid="$uuid" param-name=address)
  [[ -z "$host_ip" ]] && continue

  cpu=$(xe host-cpu-info host-uuid="$uuid" --minimal)
  [[ -z "$cpu" || "$cpu" == "0" ]] && cpu=1
  cpu_model=$(xe host-cpu-info host-uuid="$uuid" | awk -F: '/model name/ {print $2; exit}' | xargs)
  [[ -z "$cpu_model" ]] && cpu_model=$(grep -m1 "model name" /proc/cpuinfo | cut -d: -f2- | xargs)
  dom0_cpu=$(xl vcpu-list | grep -c 'Domain-0')
  load_avg=$(awk '{print $1}' /proc/loadavg)
  mem_total_bytes=$(xe host-param-get uuid="$uuid" param-name=memory-total)
  mem_free_bytes=$(xe host-param-get uuid="$uuid" param-name=memory-free)
  ctrl_mem_mib=$(xl list Domain-0 | awk 'NR==2 {print $3}')
  ctrl_mem_bytes=$((ctrl_mem_mib*1024*1024))
  mem_total_gb=$((mem_total_bytes/1024/1024/1024))
  mem_free_gb=$((mem_free_bytes/1024/1024/1024))
  ctrl_mem_gb=$((ctrl_mem_bytes/1024/1024/1024))
  mem_used_gb=$((mem_total_gb - mem_free_gb))
  vm_count=$(xe vm-list resident-on="$uuid" power-state=running | grep -i "name-label" | grep -vi "Control" | wc -l)
  ht_state=$( [[ -f /sys/devices/system/cpu/smt/active ]] && grep -q 1 /sys/devices/system/cpu/smt/active && echo "Enabled" || echo "Disabled" )
  uptime_days=$(awk '{print int($1/86400)}' /proc/uptime)

  # --- MAC + status detection ---
  eth0_status=$(cat /sys/class/net/eth0/operstate 2>/dev/null || echo "down")
  eth1_status=$(cat /sys/class/net/eth1/operstate 2>/dev/null || echo "down")
  bond_status=$(cat /sys/class/net/bond0/operstate 2>/dev/null || echo "down")

  eth0_speed=$(cat /sys/class/net/eth0/speed 2>/dev/null || echo "0")
  eth1_speed=$(cat /sys/class/net/eth1/speed 2>/dev/null || echo "0")
  bond_speed=$(cat /sys/class/net/bond0/speed 2>/dev/null || echo "0")

  eth0_mac=$(cat /sys/class/net/eth0/address 2>/dev/null || echo "not found")
  eth1_mac=$(cat /sys/class/net/eth1/address 2>/dev/null || echo "not found")
  bond_mac=$(cat /sys/class/net/bond0/address 2>/dev/null || echo "not found")

  # --- SSH-based per-host bond0 network sampling ---
  net_sample=$($SSHPASS_BIN -p "$PASS" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT root@"$host_ip" "bash -c '\
    iface=\"$IFACE\"; rx1=\$(cat /sys/class/net/\$iface/statistics/rx_bytes 2>/dev/null||echo 0); tx1=\$(cat /sys/class/net/\$iface/statistics/tx_bytes 2>/dev/null||echo 0); \
    sleep $NET_SAMPLE_SEC; \
    rx2=\$(cat /sys/class/net/\$iface/statistics/rx_bytes 2>/dev/null||echo 0); tx2=\$(cat /sys/class/net/\$iface/statistics/tx_bytes 2>/dev/null||echo 0); \
    echo \$((rx2-rx1)):\$((tx2-tx1))'") || net_sample="0:0"

  rx_bytes=$(echo "$net_sample" | cut -d: -f1)
  tx_bytes=$(echo "$net_sample" | cut -d: -f2)
  [[ -z "$rx_bytes" || -z "$tx_bytes" ]] && { rx_bytes=0; tx_bytes=0; }

  rx_mb=$(awk -v b="$rx_bytes" -v s="$NET_SAMPLE_SEC" 'BEGIN{printf "%.3f",b/(s*1024*1024)}')
  tx_mb=$(awk -v b="$tx_bytes" -v s="$NET_SAMPLE_SEC" 'BEGIN{printf "%.3f",b/(s*1024*1024)}')
  net_mb=$(awk -v a="$rx_mb" -v b="$tx_mb" 'BEGIN{printf "%.3f",a+b}')
  iface_speed_mb=$(awk -v m="$IFACE_SPEED_Mbps" 'BEGIN{printf "%.3f",m/8}')
  net_util=$(awk -v a="$net_mb" -v b="$iface_speed_mb" 'BEGIN{if(b>0) printf "%.2f",(a/b*100); else print 0.00}')

  [[ "$DEBUG" == "true" ]] && echo "DEBUG_NET: $site_name/$pool_name/$host_name → RX=${rx_mb} MB/s TX=${tx_mb} MB/s Total=${net_mb} MB/s Util=${net_util}%"

  cpu_util_percent=$(awk -v la="$load_avg" -v c="$cpu" 'BEGIN{if(c>0) printf "%.1f",(la/c*100); else print "0.0"}')
  mem_util_percent=$(awk -v u="$mem_used_gb" -v t="$mem_total_gb" 'BEGIN{if(t>0) printf "%.1f",(u/t*100); else print "0.0"}')

  sum_cpu_util=$(awk -v a="$sum_cpu_util" -v b="$cpu_util_percent" 'BEGIN{printf "%.6f",a+b}')
  sum_mem_util=$(awk -v a="$sum_mem_util" -v b="$mem_util_percent" 'BEGIN{printf "%.6f",a+b}')
  sum_net_util=$(awk -v a="$sum_net_util" -v b="$net_util" 'BEGIN{printf "%.6f",a+b}')
  host_util_count=$((host_util_count+1))

  # --- Local SR only ---
  for sr_uuid in $(xe sr-list --minimal 2>/dev/null | tr ',' ' '); do
    sr_name=$(xe sr-param-get uuid="$sr_uuid" param-name=name-label)
    sr_type=$(xe sr-param-get uuid="$sr_uuid" param-name=type)
    [[ -z "$sr_name" || "$sr_type" =~ ^(iso|udev|nfs)$ ]] && continue
    sr_total=$(xe sr-param-get uuid="$sr_uuid" param-name=physical-size)
    sr_used=$(xe sr-param-get uuid="$sr_uuid" param-name=physical-utilisation)
    sr_total_gb=$((sr_total/1024/1024/1024))
    sr_used_gb=$((sr_used/1024/1024/1024))
    sr_free_gb=$((sr_total_gb - sr_used_gb))
    echo "poolhost,$site_name,$pool_name,$host_name,$cpu,\"$cpu_model\",$dom0_cpu,$load_avg,$ctrl_mem_gb,$mem_used_gb,$mem_free_gb,$mem_total_gb,$vm_count,$ht_state,$uptime_days,$eth0_status,$eth0_speed,$eth0_mac,$eth1_status,$eth1_speed,$eth1_mac,$bond_status,$bond_speed,$cpu_util_percent,$mem_util_percent,$net_util,$sr_name,$sr_total_gb,$sr_used_gb,$sr_free_gb,$sr_type" >> "$csv_file"
    break
  done
done

# ---- NFS Section ----
echo "" >> "$csv_file"
echo "#NFS REPOSITORIES" >> "$csv_file"
echo "#KEYWORD,SITE NAME,POOL NAME,SR NAME,TOTAL(GB),USED(GB),FREE(GB)" >> "$csv_file"
xe sr-list type=nfs --minimal 2>/dev/null | tr ',' ' ' | while read -r nfs_sr; do
  [[ -z "$nfs_sr" ]] && continue
  sr_name_nfs=$(xe sr-param-get uuid="$nfs_sr" param-name=name-label)
  sr_total_nfs=$(xe sr-param-get uuid="$nfs_sr" param-name=physical-size)
  sr_used_nfs=$(xe sr-param-get uuid="$nfs_sr" param-name=physical-utilisation)
  total_gb_nfs=$((sr_total_nfs/1024/1024/1024))
  used_gb_nfs=$((sr_used_nfs/1024/1024/1024))
  free_gb_nfs=$((total_gb_nfs - used_gb_nfs))
  echo "nfs,$site_name,$pool_name,$sr_name_nfs,$total_gb_nfs,$used_gb_nfs,$free_gb_nfs" >> "$csv_file"
done

echo "$pool_name,$csv_file"
EOSCRIPT

# ---------------------------------------------------------------------
# Collect results, merge, cleanup (same as before)
# ---------------------------------------------------------------------
export PASS IFACE IFACE_SPEED_Mbps NET_SAMPLE_SEC SSH_TIMEOUT DEBUG

while read -r server; do
  [[ -z "$server" || "$server" =~ ^\s*# ]] && continue
  echo "Collecting data from $server ..."
  result=$($SSHPASS_BIN -p "$PASS" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" "bash -s" <<< "$REMOTE_SCRIPT" 2>/dev/null)
  [[ "$DEBUG" == "true" ]] && echo "$result" | grep "DEBUG_NET"
  pool_name=$(echo "$result" | awk -F',' '{print $1}')
  remote_csv=$(echo "$result" | awk -F',' '{print $2}')
  [[ -z "$pool_name" || -z "$remote_csv" ]] && continue
  clean_pool=$(echo "$pool_name" | tr -dc 'A-Za-z0-9_-')
  local_csv="${TMP_DIR}/${clean_pool}_${DATESTAMP}.csv"
  $SSHPASS_BIN -p "$PASS" scp -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server:$remote_csv" "$local_csv" >/dev/null 2>&1
  [[ -f "$local_csv" ]] && echo "${pool_name},${server},${local_csv}" >> "$MASTER_INDEX"
done < <(grep -v '^\s*#' "$SERVER_LIST" | sed '/^\s*$/d')

MERGED_CSV="${TMP_DIR}/xenpool_final_merged.csv"
> "$MERGED_CSV"
TMP_HOSTS="${TMP_DIR}/tmp_hosts_merge.csv"
TMP_NFS="${TMP_DIR}/tmp_nfs_merge.csv"
> "$TMP_HOSTS"; > "$TMP_NFS"

while IFS=, read -r pool_name server csv_file; do
  [[ -z "$csv_file" || ! -f "$csv_file" ]] && continue
  awk -F, '/^poolhost,/ {print}' "$csv_file" >> "$TMP_HOSTS"
  awk -F, '/^nfs,/ {print}' "$csv_file" >> "$TMP_NFS"
done < "$MASTER_INDEX"

{
  echo "#HOST DETAILS (All Pools)"
  echo "#KEYWORD,SITE NAME,POOL NAME,HOST NAME,CPU,CPU_MODEL,DOM0_CPU,LOAD_AVG,CTRL_MEM(GB),USED_MEM(GB),FREE_MEM(GB),TOTAL_MEM(GB),RUNNING_VM,HYPERTHREADING,UPTIME_DAYS,ETH0_STATUS,ETH0_SPEED,ETH0_MAC,ETH1_STATUS,ETH1_SPEED,ETH1_MAC,BOND0_STATUS,BOND0_SPEED,CPU_UTIL(%),MEM_UTIL(%),NET_UTIL(%),SR NAME,SR TOTAL(GB),SR USED(GB),SR FREE(GB),SR TYPE"
  cat "$TMP_HOSTS"
  echo ""
  echo "#NFS REPOSITORIES (All Pools)"
  echo "#KEYWORD,SITE NAME,POOL NAME,SR NAME,TOTAL(GB),USED(GB),FREE(GB)"
  cat "$TMP_NFS"
} > "$MERGED_CSV"

echo "Merged CSV successfully written to: $MERGED_CSV"

# Cleanup
mapfile -t SERVER_ARRAY < <(grep -v '^\s*#' "$SERVER_LIST" | sed '/^\s*$/d')
for server in "${SERVER_ARRAY[@]}"; do
  echo "Cleaning remote temporary files on $server ..."
  $SSHPASS_BIN -p "$PASS" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=$SSH_TIMEOUT "$USER@$server" \
    "rm -f /tmp/xenpool_summary_*.csv" >/dev/null 2>&1
done

find "$TMP_DIR" -type f ! -name "xenpool_final_merged.csv" -exec rm -f {} +
cp "$MERGED_CSV" /u/arghyaa/ctx-report/ 2>/dev/null || true
echo "Cleanup completed. Final report: $MERGED_CSV"
rm -f "$LOCKFILE" 2>/dev/null || true
exit 0
